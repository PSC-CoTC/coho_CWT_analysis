---
title: "Coho FRAM Model Validation and Mixed Stock Model Updating"
author: "A Hagen-Breaux, Carrie Cook-Tabor, Dan Auerbach"
date: "`r Sys.Date()`"
output:
  word_document: null
  bookdown::html_document2:
    fig_caption: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: hide
always_allow_html: yes
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
subtitle: Southern Fund Project 2019-SP-3A
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, results = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9)

library("tidyverse")
# install.packages("devtools")
# devtools::install_github("BSchamberger/RDCOMClient")
# devtools::install_github("FRAMverse/framr")

library(framr)
library("odbc"); library("DBI")
library("patchwork")
library(rstatix)
library(ggpubr)
library(broom)
library(modelr)
library(reactable)


table_dir<-"C:/Data/CoTC/SouthernFund/2019/2019SouthernFundProject/DataSF19/"

mdb<-"C:/data/CoTC/PostseasonRuns/PostDB/PSC_CoTC_PostSeason_CohoFRAMDB_thru2020_021622.mdb"  
#wacolors::pal_vector("coast", 3) #c("#7BAEA0", "#386276", "#3A4332")
#wacolors::pal_vector("rainier", 3)
pal = c("#465177", "#E4C22B", "#965127")

d_fishmap<-read.csv(file.path(table_dir,"FishMapAug26_2022.csv"))
d_uniquefishery<-read.csv(file.path(table_dir,"MR_FishMapUnique.csv"))
d_uniquefishery2<-read.csv(file.path(table_dir,"MR_FishMapUnique2.csv"))
d_tSlu<-read.csv(file.path(table_dir,"ts_lu.csv"))
d_fishscalar<-framr::read_coho_fish_sclr(mdb,runs = 34:42) |> 
    select(RunYear, FisheryID, TimeStep, FisheryFlag, MarkReleaseRate)
d_exclude_fish<-read.csv(file.path(table_dir,"MR_ExcludeFish.csv"))
t_unclipped<-read.csv(file.path(table_dir,"MR_unclipped.csv"))
t_prmu<-read.csv(file.path(table_dir,"PR_MU.csv"))
d_stockmap<-read.csv(file.path(table_dir,"ER_Stock_CWT07112022.csv"))
d_ERtrollsum<-read.csv(file.path(table_dir,"ER_Ttrollsum.csv"))
d_top10<-read.csv(file.path(table_dir,"Fish43top10.csv"))

#needed to combine T/NT net pairs. Do not combine T/NT troll (different MSF regs)
Tpair<-c(80,82,87,96,101,109,111,119,121,123,130,132,137,139,141,143,145,153,155,157,159)

```

```{r d_samp}
d_samp <- read_csv(file.path(table_dir, "MR Sampling Data.csv")) 
  # get FishIDs for sport fisheries for later use
  sampsportID<-unique(d_samp[d_samp$Gear=="Sport",3])|>
    filter(!is.na(FisheryID))
    sort(sampsportID$FisheryID)
  #exclude some non-FRAM areas without FishID
 d_samp<-d_samp|>
   filter(
    !is.na(FisheryID)) |> 
  select(RunYear = Year, FisheryID, TimeStep = TS, #Flag,
         MK = `Mrkd Landed`,
         UK = `UM Landed`,
         MR = `Mrkd Released`,
         UR = `UM Released`
         ) |> 
  mutate(
    FisheryID = if_else(FisheryID %in% Tpair, FisheryID+1, FisheryID) 
    ) |> #count(Flag)
  group_by(RunYear, FisheryID, TimeStep) |> #, Flag
  summarise(across(MK:UR, sum), .groups = "drop")  #count(Flag) 
  # only calculate landed mark rate if sum of marked and unmarked >20
  # calculate encounter mark rate if sum of all encounters >20
  d_samp<-d_samp|>
  
    mutate(
    mr_kept = MK/(MK+UK),
    mr_enc = (MK+MR)/(MK+UK+MR+UR)
  ) |> 
  dplyr::rename_at(vars(MK:mr_enc), ~paste0(.,"_samp")) |> 
  filter(!is.na(mr_enc_samp))|>
   mutate(
     Source = "Sampling"
   )
   
#use Encounters for MSF Sport and Landed for NS 
  d_samp<-left_join(d_samp,d_fishscalar|>
  select(RunYear,FisheryID,TimeStep,FisheryFlag),
         by=c("RunYear","FisheryID","TimeStep"))
  
   d_samp<-d_samp|>
    mutate(
      Type = ifelse(FisheryFlag>2,"Encounters","Landed")
    )|>
 mutate(
   TotalLanded = MK_samp+UK_samp,
   TotalEncounters = MK_samp+UK_samp+MR_samp+UR_samp,
   MrkdEncounters = MK_samp + MR_samp
 )|>
   mutate(
     Total_samp = ifelse(Type=="Encounters",TotalEncounters,TotalLanded),
     Marked_samp = ifelse(Type=="Encounters",MrkdEncounters,MK_samp),
     MR_sampl = ifelse(Type=="Encounters",mr_enc_samp,mr_kept_samp)
   )
 
 d_samp<-d_samp[,c(1:3,16:18,10,11,12)]|>
   filter(!is.na(MR_sampl))|>
   filter(!is.na(FisheryFlag))|>
   filter(!FisheryFlag == 0)|>
   filter(!FisheryFlag == 28)
 #eliminate MSF troll fisheries Type= Encounters FisheryID = 34,35,38,42. Sampling for these fisheries only records landed catch
 troll<-c(34,35,38,42)
 d_samp<-d_samp|>
   filter(!FisheryID %in% troll )|>
   filter(!Total_samp<20)
  
 write.csv(d_samp,"d_samp.csv")
```

```{r d_rmisraw}

# data pulled from RMIS CatchSample May 17, 2022 with only a species (Coho) and years (2010 to 2020) filter
d_rmisraw<-read.csv(file.path(table_dir,"MR_RMIS2010_20CohoMrkSample.csv"))
# fisheries that remained unassigned after the first round were added to 
# the fishmap file based on best fit, with some exceptions that remained unmapped
# such as 1M2, 1M3, 1M4, Oregon Net etc.

#Clean and summarize data
#maps CatchSample data to FRAM fisheries
d_rmisraw2<-d_rmisraw%>%
  add_column (FisheryID = 0)
# add blanks to end of recovery location code
d_rmisraw2$catch_location_code<-paste(d_rmisraw2$catch_location_code,"    ")

for (i in 1:nrow(d_fishmap)) {
  numchars<-d_fishmap[i,4]
  gear<-d_fishmap[i,3]
  FishID2<-d_fishmap[i,1]
  FishName2<-d_fishmap[i,2]
  locc<-substr(d_fishmap[i,5], 1, numchars)
  i=i+1
#find all the records in rmis_recrel with matching fishery and location codes
# update FishID and FishName fields to FishID and FishName
# assign fishery 50-59 to escapement  
  if (gear == 5){
    d_rmisraw2<-within(d_rmisraw2,FisheryID[floor(fishery/10) ==gear ]<-FishID2)
  } else {
     d_rmisraw2<-within(d_rmisraw2,FisheryID[floor(fishery/10) ==gear & substr(catch_location_code,start=1,stop=numchars) ==locc]<-FishID2)
 }  
}
#assign unassigned records with a freshwater sampling location to escapement
d_rmisraw2<- within(d_rmisraw2, FisheryID[FisheryID==0 & substr(catch_location_code,2,2) == "F"]<-300) 

#add Treaty ocean troll designation
NT_ocean_troll<-c(35,38,42)
d_rmisraw2$FisheryID = ifelse(d_rmisraw2$fishery ==15 & d_rmisraw2$FisheryID %in% NT_ocean_troll, d_rmisraw2$FisheryID + 1,d_rmisraw2$FisheryID)

write.csv(d_rmisraw2,"drmisraw2.csv")
  
#add Fishery Name
SoFtroll<-c(18,20,22)

d_rmisraw2<-left_join(d_rmisraw2,d_uniquefishery %>% select(FisheryID,FisheryName), by = c("FisheryID"))|>
  # eliminate Newport,Coos Bay, Tillamook troll, very low mark rate based on only one or two years of sampling with low sample rate
filter(!FisheryID %in% SoFtroll)

for (i in 1:nrow(d_rmisraw2)) {
  if (d_rmisraw2$FisheryID[i] %in% Tpair){
    d_rmisraw2$FisheryID[i]<- d_rmisraw2$FisheryID[i]+1
  } else {
    d_rmisraw2$FisheryID[i]<- d_rmisraw2$FisheryID[i]
 }  
}

d_junk<-d_rmisraw2|>
  group_by(FisheryID)|>
  summarize(n = n())
 

# eliminate records with no sampling to later compute a new sampling expansion
d_rmis_no_samp<-d_rmisraw2[,c(3,13,14,15,20,21)]|>
  filter(number_sampled>0,
         number_caught>0,
         sample_type!=5)|>
  select(-sample_type)|>
  dplyr::rename("RunYear"=catch_year)|>
  group_by(RunYear,FisheryID,FisheryName)|>
  summarise(across(c(number_caught,number_sampled),sum))


#for use in comparing FRAM and RMIS Catches see Data Preparation
rmis_landed<-d_rmisraw2[,c(3,14,15,20,21)]|>
  filter(!is.na(number_caught))|>
dplyr::rename("Total_rmis"=number_caught,
       "Sampled_rmis"=number_sampled,
       "RunYear"=catch_year)|>
  group_by(RunYear,FisheryID,FisheryName)|>
  summarise(across(c(Total_rmis,Sampled_rmis),sum),.groups="drop")


 # add time steps
d_rmis3<-left_join(d_rmisraw2,d_tSlu,by=c('period_type'='PeriodType','period'='Period'))|>
  #clean data
#Eliminate records where mark rate is na
filter(!is.na(mark_rate))|>
#eliminate records where number caught is na
filter(!is.na(number_caught))|>
#eliminate records where number caught is zero
filter(!number_caught==0) |>
#eliminate records where number sampled is na
filter(!is.na(number_sampled))|>
#eliminate records where number sampled is zero
filter(!number_sampled==0)|>
#calculate the number marked
mutate(number_marked = number_caught * mark_rate) |> 
#eliminate records where adclip_selective_fishery = M (mixed) 
filter(!adclip_selective_fishery=="M")|>
#eliminate Skagit FW sport. Only one year of sampling in the Cascade which appears to have a different mark rate (higher) than the Skagit River fishery modeled in FRAM. Eliminate Quinault net. Only one record that has a mark sample. This record has a mark rate of zero. This result is highly improbable.
filter(!FisheryID %in% c(108,63))


write.csv(d_rmis3,"d_rmis3.csv")

#sum number marked by fishery, year, and time step
d_rmis<-d_rmis3 |>
  group_by(catch_year, FisheryID, TimeStep) |> 
summarise(across(c(number_caught,number_marked,number_sampled), sum), .groups = "drop")|>
  mutate(MR_rmis = number_marked/number_caught)|>
#eliminate records where number sampled < 20
filter(!number_sampled<20)
d_rmis<-d_rmis[,c(1:5,7)]|>
  mutate(Source = "RMIS")|>
  mutate(Type = "Landed")
colnames(d_rmis)[1]<- "RunYear"
colnames(d_rmis)[4]<- "Total_rmis"
colnames(d_rmis)[5]<- "Marked_rmis"
colnames(d_rmis)[2]<-"FisheryID"

write.csv(d_rmis, "d_rmis.csv")
```

```{r d_fram}
#framr is an r package that processes data in FRAM AcCESSDB
#data from "PSC_CoTC_PostSeason_CohoFRAMDB_thru2020_021622.mdb"

# d_fram_mort <- framr::read_coho_mort(mdb, runs = 34:44) |>
#   select(RunID, RunYear, StockID, FisheryID, FisheryName, TimeStep, LandedCatch, MSFLandedCatch, MSFNonRetention)
# 
# mdb_con <- DBI::dbConnect(drv = odbc::odbc(), .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", mdb, ";"))
# 
# d_fram_fs <- tbl(mdb_con, "FisheryScalers") |> filter(RunID %in% 34:42) |> select(RunID:TimeStep, MarkReleaseRate) |> collect()
# 
# DBI::dbDisconnect(mdb_con)


d_fram <- left_join(
  framr::read_coho_mort(mdb, runs = 34:44) |> 
    select(RunYear, StockID, FisheryID, TimeStep, LandedCatch, MSFLandedCatch, MSFNonRetention) |> 
    mutate(RunYear = as.numeric(RunYear))
  ,
  d_fishscalar
  ,
  #d_fram_mort, d_fram_fs,
  by = c("RunYear","FisheryID","TimeStep")
) |> #filter(FisheryID %in% 96:97) |> count(FisheryID, FisheryName)
  mutate(
    MarkStatus = if_else(StockID %% 2 == 0, "M", "UM"),
    FisheryID = ifelse(FisheryID %in% Tpair, FisheryID+1, FisheryID),
    Kept = LandedCatch + MSFLandedCatch,
    Enc = LandedCatch + MSFLandedCatch + if_else(MarkReleaseRate>0,MSFNonRetention/MarkReleaseRate,0)
  ) 
#re-flag 1s to 2s.In post-season runs fisheries should all be flagged as 2. This will avaoid potential duplicates for T/NT fishing pairs
  d_fram[which(d_fram$FisheryFlag == 1),]$FisheryFlag=2
 
   d_fram<-d_fram|>
     
  group_by(RunYear, FisheryID,MarkStatus, TimeStep,FisheryFlag)|>
  summarize(across(Kept:Enc,sum),.groups = "drop")|>
  pivot_wider(names_from = MarkStatus, values_from = c(Kept,Enc))|>
  mutate(
    mr_kept = Kept_M/(Kept_M+Kept_UM),
    mr_enc = Enc_M/(Enc_M+Enc_UM)
  ) |>
  dplyr::rename_at(vars(Kept_M:mr_enc), ~paste0(.,"_fram"))  
  
     # for landed catch comparison with RMIS
fram_landed<-d_fram[,c(1:6)]|>
  mutate(Total_fram =Kept_M_fram + Kept_UM_fram )|>
  group_by(RunYear,FisheryID)|>
summarise(across(c(Kept_M_fram,Total_fram),sum),.groups="drop")
     
          
d_fram<-d_fram|>     
  filter(!is.na(mr_enc_fram))|>
  filter(!FisheryFlag>8)|> #exclude mixed MSF/NS fisheries
mutate(Source = "FRAM")

 

   
d_fram<-d_fram[,c(1:4,7,8,10,11)]|>
  mutate(Type = "Encounters",
         Total = Enc_M_fram + Enc_UM_fram
         )
  colnames(d_fram)[5]<-"Marked"
  colnames(d_fram)[7]<-"MR"
d_fram<-d_fram[,c(1:4,10,5,7:9)]
  

write.csv(d_fram, "d_fram.csv")
```


```{r}
 #nothing in sampling dataset that isn't in fram dataset
setdiff(unique(d_samp$FisheryID), unique(d_fram$FisheryID))
#but lots of fram fisheries for which we don't have sampling obs...
sort(setdiff(unique(d_fram$FisheryID), unique(d_samp$FisheryID)))

#join to sampling if MSF, join to RMIS if non-selective

# d_samp<-d_samp|>
#   group_by(RunYear,FisheryID,TimeStep,Source,Type)|>
#   summarise(across(c(Total_samp,Marked_samp,MR_sampl),sum),.groups="drop")

d_fram_joined1 <- d_fram|>
  filter(FisheryFlag ==8)|>
  inner_join(
    d_samp[,-c(8)],
    by=c("RunYear","FisheryID","TimeStep")
)

colnames(d_fram_joined1)[10]<-"Total"
colnames(d_fram_joined1)[11]<-"Marked"
colnames(d_fram_joined1)[12]<-"MR"


d_fram_joined2<-d_fram|>
  filter(!FisheryFlag==8)|>
  inner_join(
    d_rmis,
    by=c("RunYear","FisheryID","TimeStep")
)
colnames(d_fram_joined2)[10]<-"Total"
colnames(d_fram_joined2)[11]<-"Marked"
colnames(d_fram_joined2)[12]<-"MR"

mr_fram_samp_rmis <-rbind(d_fram_joined1,d_fram_joined2)

colnames(mr_fram_samp_rmis)[10]<-"Tot_samp"
colnames(mr_fram_samp_rmis)[11]<-"Marked_samp"
colnames(mr_fram_samp_rmis)[12]<-"MR_samp"

mr_ts_fram_samp_rmis <-left_join(mr_fram_samp_rmis,d_uniquefishery %>% select(FisheryID,FisheryName), by = c("FisheryID"))

write.csv(mr_fram_samp_rmis,"mr_check.csv")

#sum over time steps before computing annual rates. It's okay to ignore Flags and Type (based on data QAQC). Conduct analyses on annual mark rates, because many FRAM fisheries are not reported in the time step they actually occur; i.e., PS fw fisheries are modeled in time 5 even if most catch occurs in time 4.

d_fram_yr<-d_fram|>
  group_by(RunYear,FisheryID,FisheryFlag,Source,Type)|>
  summarise(across(c(Total,Marked,MR),sum),.groups="drop")|>
  mutate(MR=Marked/Total)|>
  left_join(d_uniquefishery|>
              select(FisheryID,FisheryName), by = c("FisheryID"))

d_samp_yr<-d_samp|>
  filter(Type != "Landed")|>
  group_by(RunYear,FisheryID,Source,Type)|>
  summarise(across(c(Total_samp,Marked_samp,MR_sampl),sum),.groups="drop")|>
  mutate(MR_sampl=Marked_samp/Total_samp)

#include RMIS time steps for non-selective fisheries that are modeled in a different time step in FRAM

d_rmis_yr<-d_rmis|>
  left_join(d_fram|>
              select(RunYear,FisheryID,TimeStep,FisheryFlag), by = c("RunYear","FisheryID","TimeStep"))|>
rowid_to_column("uid")

d_rmis_yr<-d_rmis_yr|>
  nest_by(FisheryID, RunYear) |>
  #same as: group_by(FisheryID, RunYear) |> nest() |> rowwise() |>
  filter(
    nrow(data) >= 2 &
      nrow(data |> filter(is.na(FisheryFlag) & MR_rmis < 0.95) > 0) &
        nrow(data |> filter(FisheryFlag == 2) > 0)
    ) |>
  unnest(data) |> ungroup() |>
  split(f = ~FisheryID + RunYear, drop = T) |>
  map_df(
    function(d){
      ts_na = d |> filter(is.na(FisheryFlag) & MR_rmis < 0.95) |> pluck("TimeStep")
      
      if(length(ts_na) > 1) {
        map_df(
          ts_na,
          function(ts){
            ff_pre = d |> filter(TimeStep == ts - 1) |> pluck("FisheryFlag", .default = NA)
            ff_pst = d |> filter(TimeStep == ts + 1) |> pluck("FisheryFlag", .default = NA)
            if(!all(is.na(c(ff_pre, ff_pst)))){
              if(ff_pre == 2 | ff_pst == 2){
                d |> filter(TimeStep == ts) |> select(uid) |> mutate(flag = "3")
              }
            } 
          })
        
      } else {
        ff_pre = d |> filter(TimeStep == ts_na - 1) |> pluck("FisheryFlag", .default = NA)
        ff_pst = d |> filter(TimeStep == ts_na + 1) |> pluck("FisheryFlag", .default = NA)
        if(!all(is.na(c(ff_pre, ff_pst)))){
          if(ff_pre == 2 | ff_pst == 2){
            d |> filter(TimeStep == ts_na) |> select(uid) |> mutate(flag = "3")
          }
        }
      }
    }
  ) %>%
  left_join(d_rmis_yr, y = ., by = "uid")|>
  filter(FisheryFlag==2 | flag==3)|>
  #eliminate non-selective fisheries with MR >0.98% These are likely MSFs placed in the wrong time step due to RMIS management week structure
filter(MR_rmis<0.98)

#write.csv(d_rmis_yr,"d_rmis_yr.csv")
# for (i in 1:nrow(d_rmis_yr)) {
#   Tstep<-d_rmis_yr$TimeStep[i]
#   runyr<- d_rmis_yr$RunYear[i] #d_rmis_yr[i,"RunYear"]
#   fid<-d_rmis_yr$FisheryID[i]
#   fflag<-d_rmis_yr$FisheryFlag[i]
#   mrkrate<-d_rmis_yr$MR_rmis[i]
#   if (is.na(fflag) & mrkrate<0.95) {
#     other_ts <- d_rmis_yr[ 
#       d_rmis_yr$RunYear == runyr &
#       d_rmis_yr$FisheryID == fid & 
#       d_rmis_yr$FisheryFlag == 2 &
#       (d_rmis_yr$TimeStep == Tstep + 1 | d_rmis_yr$TimeStep == Tstep - 1 ) ,]
#     if(nrow(other_ts) > 0) {
#       d_rmis_yr$FisheryFlag[i]<-3
#     }
#   }
# }



d_rmis_yr<-d_rmis_yr[,c(2:9)]|>
   group_by(RunYear,FisheryID,Source,Type)|>
  summarise(across(c(Total_rmis,Marked_rmis,MR_rmis),sum),.groups="drop")|>
  mutate(MR_rmis=Marked_rmis/Total_rmis)

mr_yr_fram_join_samp<-d_fram_yr|>
  filter(FisheryFlag ==8)|>
  inner_join(
    d_samp_yr,
    by=c("RunYear","FisheryID")
)
mr_yr_fram_join_rmis<-d_fram_yr|>
filter(FisheryFlag !=8)|>
  inner_join(
    d_rmis_yr,
    by=c("RunYear","FisheryID")
  )|>
  dplyr::rename(Total_samp = Total_rmis)|>
  dplyr::rename(Marked_samp = Marked_rmis)|>
  dplyr::rename(MR_sampl=MR_rmis)

mr_yr_fram_samp_rmis<-rbind(mr_yr_fram_join_samp,mr_yr_fram_join_rmis)|>
  mutate(RelPctDiff = (MR_sampl-MR)/MR_sampl,
         AbsPctDiff = (MR_sampl-MR))
  
 # dplyr::rename(FisheryName = FisheryName.x)

write.csv(mr_ts_fram_samp_rmis, "MR_TS.csv")
#write.csv(mr_yr_fram_samp_rmis, "MR_Yr.csv")
#d_fram_sport<-d_fram[is.element(d_fram$FisheryID,sampsportID$FishID),]

write.csv(mr_fram_samp_rmis,"mr_fram_samp.csv")

# compare landed RMIS to landed sampling for non-selective fisheries
       
# mr_rmis_samp<-left_join(mr_rmis_samp,d_uniquefishery %>% select(FRAM_Fish_ID,FRAM_Fish_Name), by = c("FisheryID"="FRAM_Fish_ID"))
mr_rmis_samp<-d_samp|>
  #filter(Type=="Landed")|>
  inner_join(
  d_rmis,
  by=c("RunYear","FisheryID","TimeStep")
)|>
  left_join(
    d_uniquefishery,
    by=c("FisheryID")
  )
# #add fishery flag
# mr_rmis_samp<-left_join(mr_rmis_samp, d_fram%>%                          select(RunYear,FisheryID,TimeStep,FisheryFlag),
#                         by=c("RunYear","FisheryID","TimeStep"))
#eliminate MSF
mr_rmis_samp<- mr_rmis_samp|>
  filter(FisheryFlag<=2)

write.csv(mr_rmis_samp, "mr_RMIS_SAMP.csv")



mr_fram_samp_long <- left_join(mr_fram_samp_rmis,d_uniquefishery %>% select(FisheryID,FisheryName), by = c("FisheryID"))|>
  select(RunYear, FisheryID, FisheryName, TimeStep, starts_with("MR")) |> 
  pivot_longer(names_to = "type", values_to = "val", cols = starts_with("MR"))
colnames(mr_fram_samp_long)[3]<-"FisheryName"
mr_fram_samp_long$type[mr_fram_samp_long$type!="MR_samp"]<-"MR_fram"

mr_rmis_samp_long <- mr_rmis_samp |> 
  select(RunYear, FisheryID, FisheryName, TimeStep, MR_sampl ,MR_rmis) |>
  pivot_longer(names_to = "type", values_to = "val", cols =  c("MR_sampl","MR_rmis"))
colnames(mr_rmis_samp_long)[3]<-"FisheryName"


```



# Acknowledgements

# Prequel DA help with what to call this chapter

## Glossary

### **Backwards FRAM (BkFRAM):** {#BkFRAM}
BkFRAM is a FRAM utility that reconstructs starting Cohorts by adding user inputted fisheries mortalities and escapements for the purpose of producing post-season model runs (Hagen-Breaux 2018). FRAM iteratively adjusts stock recruit scalars (a surrogate for starting Cohorts) and runs FRAM forward until the resulting escapements match user inputted annual escapement estimates.

### **Extreme Terminal:**
Marine area directly adjacent to salmon native streams with a very high proportion of catch made up of the "local stocks" due to river mouth proximity; i.e., Elliott Bay is the extreme terminal area for Green River Chinook and Coho.

### **Fisheries Regulation Assessment Model (FRAM):** {#FRAM}
Model used by the Pacific Salmon Commission[^1], Pacific Fishery Management Council, Washington Department of Fish and Wildlife, and Puget Sound Treaty Tribes to evaluate the effects of fisheries on Chinook and Coho fisheries.

### **Full Join:** {#fulljoin}
A data join returning rows from the joined tables, whether they are matched or not.

[^1]: The PSC Coho Technical Committee uses FRAM to evaluate exploitation rates on Coho whereas PSC Chinook Technical Committee uses a different model for Chinook. 

### **Mark Rate:** 
The mark rate of a fishery is computed as marked encounters divided by total encounters in the fishery.

### **Mixed Stock Model (MSM)** {#MSM}
Computer program used to build the current Coho base period from 1986-1992 coded-wire-tags, resulting in the base period exploitation rates utilized in contemporary [FRAM](#FRAM) runs.

### **North of Falcon (NOF):**
Co-manager, annual, pre-season Puget Sound salmon fishery planning process; referencing the region North of Cape Falcon, OR, which marks the southern border of active management for Washington salmon stocks.
 
### **Pacific Salmon Commission (PSC):** 
A commission composed of Canadian and United States representatives tasked with developing and upholding the PST.

### **Pacific Salmon Treaty** [(PST):](https://www.psc.org/about-us/history-purpose/pacific-salmon-treaty/) 
Treaty between the Government of Canada and the Government of the United States of America concerning Pacific Salmon.

### **Regional Mark Information System (RMIS):** {#RMIS}
Regional Mark Information System – the databases of the Regional Mark Processing Center storing Pacific Coast-wide anadromous salmon adipose marking information, coded-wire tag releases and recoveries, recovery locations, and sampling information.

### **South of Falcon (SOF):**
Referencing the region South of Cape Falcon (OR) which marks the southern border of active management for Washington salmon stocks.

### **Starting Cohort: **
Initial run sizes before natural mortality and fishing mortality at the beginning of the run year.

### **Time Steps:**
Coho FRAM has 5 time steps.

- Time 1: January – June

- Time 2: July

- Time 3: August

- Time 4: September

- Time 5: October - December





---

```{js, echo=FALSE}
// Place footnotes after glossary section
$(document).ready(function() {
  $('.footnotes ol').appendTo('#glossary');
  $('.footnotes').remove();
});
```

## List of Figures

## List of Tables

## Executive Summary

# Introduction
talk about mixed stock model

# Data Preparation

## Assigning Coded-Wire-Tagged Groups to Mixed-Stock Model Stocks

x: Explain changes to CWT summary due to not using MSM for the analysis

In order to estimate stock composition in pre-terminal mixed stock fisheries, the 'User' must identify: (1) The Production Regions (PRs) or Management Units (MUs) and associated coded-wire tag (CWT) codes selected to characterize fishery composition profiles for each modeled stock; and (2) The fishery strata to be used for estimation.
This section describes the steps taken to identify and map available Coho Salmon CWTs to the list of PRs and MUs within FRAM.  All available Coho Salmon Release and Recovery data were downloaded from the Regional Mark Processing Center [(RMIS)](https://www.rmis.org/cgi-bin/queryfrm.mpl?Table=catch_sample&Version=4.1) in July of 2020 and uploaded into a Microsoft Access Database called 'MappingDatabase.mdb'.  A total of 17,268 CWT groups were downloaded and ranged from brood year 1969 to 2019.  Once the data was loaded, the following steps were taken to create the stock assignments:

1.	'Mark Status' was determined for each CWT group released.  Release and recovery data were examined to determine the intended mark status of each of the CWT release groups.  For release groups identified as being marked, the estimated number of CWTs recovered from fisheries were summarized by 'recorded_mark' and compared to the mark type listed under 'cwt_1st_mark'. The CWT was flagged for further review if more than 20% of the fishery recoveries were identified as having a different mark than what was listed in the release data.  Final review of all of these flagged CWTs yielded a total of 15 tag codes with the intended mark type differing from the mark type listed under 'cwt_1st_mark' (see Appendix Table 9.4 for the list of these tags).  A table called 'CWT_1st_mark_fixes' was created in the Access database and a query titled 'Step1- Fix CWT_1st_Mark value' was used to update the release data that was downloaded from RMIS into the database to correct the 'cwt_1st_mark'.

2.	Releases were grouped and assigned to PRs and MUs. To streamline assigning release groups to PRs and MUs, a list of unique combinations of the following data was generated and saved in a table titled 'RMIS_UniqueReleaseCodes' within the Access database: 
*	release_location_state
*	release_location_rmis_region
*	release_location_rmis_basin
*	release_location_name
*	hatchery_location_name
*	stock_location_name

This table consisting of a total of 2,058 unique combinations was then copied to a table titled 'RMIS_UniqueReleaseCodesMapped' and a column containing the assigned PR and another containing the MU were added.  Production Regions and Management Units were manually assigned to each unique record.  The PRs and MUs available to use are listed in Appendix Table 9.5. For a list of mapped CWT codes see Appendix Table 9.6. Here is an example of a unique combination within the 'RMIS_UniqueReleaseCodesMapped' table that was mapped to a PR and an MU:

```{r results ='asis'}
# Save table information as a tibble
dplyr::tibble(`release location state` = "AK",
       `release location rmis region` = "ALSR",
        `release location rmis basin` = "ALSRG",
       `hatchery location name` = "NA",
       `stock location_name` = "AKWE R",
        `release_location name` = "AKWE R 182-40",
       `PR` = "Northern Alaska Outside",
        `MU` = "Alaska Northern Outside Hat/Wild",
       ) |> 
  # Format as a table
  gt::gt() |> 
  # Make column headers bold
  
  # Add title text
  gt::tab_header(title = "Table 4.1. Unique Release Codes Mapped")

```
  
<br>
3.	Assign MUs to the Columbia River releases.  The Columbia River Production Region consists of two types of Coho Salmon – the South or Early returning stocks (also known as A-Type or fall type run) and the North or Late returning stocks (also known as B-Type or late-fall run).  While there is a field in RMIS that provides the run type, this data was missing for many of the releases.  Over 1,500 CWT releases within the Columbia River Basin did not have a run type associated with them.  Because of this, a summary of these tag codes was provided to Eric Kinne and Jillian Cady of WDFW to review.  They provided MU assignments for the CWTs with blank MUs and confirmed all of the preliminary assignments for the remaining records.   This resulted in the following assignments summarized by MU:

```{r results ='asis'}
# Save table information as a tibble
dplyr::tibble(`Management Unit` = c("Columbia River Early Hatchery", "Columbia River Late Hatchery", "Lower Col R Oregon Wild","Wash Early Wild","Wash Late Wild","Youngs Bay Hatchery", "Grand Total"),
              `Number of CWTs Released` = c(1430,594,9,114,25,836,3008)
       ) |> 
  # Format as a table
  gt::gt() |> 
  # Make column headers bold
   gt::cols_label(.list = list(`Management Unit` = gt::md("**Management Unit**"), 
                              `Number of CWTs Released` = gt::md("**Number of CWTs Released**")))|>
   gt::tab_style(
     style  = 
      gt::cell_text(weight = "bold"),  
      locations = gt::cells_body(
      columns = everything(),
      rows=7))|>                        
  # Add title text
  gt::tab_header(title = "Table 4.2. Columbia River Stock Assignments and Numbers Released")

```
<br>
The next step was to run a query in the Access database to update all of the Columbia River CWTs with these newly assigned MUs.


4. Create CWT data input files for use in the Mixed Stock Model (MSM).  A query titled 'Map releases to PR and MU number' was used to link information on PRs and MU numbers and the brood year for the individual CWTs and assigns them to RunIDs, which are unique to a catch year.  The use of this query creates MSM input files containing the following data:
<br>
```{r results ='asis'}
# Save table information as a tibble
dplyr::tibble(`Run ID` = 9,
       `PR Number` = 16,
        `PR MU Number` = 0,
       `CWT Code` = 011044,
       `Number Released` = 1000,
        `Release name` = "BURNT HILL CR (OPSR)",
       `Hatchery name` = "ORE-PAC SALMON RANCH",
        `Stock Name` = "NESTUCCA R PRIVATE",
       `brood year` = 1995
       ) |> 
  # Format as a table
  gt::gt() |> 
  
  # Add title text
  gt::tab_header(title = "Table 4.3. MSM Stock CWT 1998")


```

## Assigning Coded-Wire-Tagged Recoveries to FRAM Fisheries {#fishmap}
Fishery definitions are located in Appendix X. 
Recoveries with a gear code between 50 and 59 were assigned to escapement.
Explain why fishery 199 is missing

## Data Quality Issues

### List of Data Issues Confounding Analyses
Exploitation rate analyses for the purpose of constructing and populating coast-wide salmon models are extremely data intense, requiring millions of data points. FRAM and the Mixed-Stock-Model integrate the many staff hours of salmon monitoring data, rolling them up into literally thousands of inputs upon which the model runs; in a sense, FRAM is the center of the Coho monitoring data universe. The majority of the data is either reported using sophisticated reporting and data storing mechanisms or sampled by coast-wide monitoring programs. Frequently, the data is manipulated, adjusted, and expanded to arrive at final estimates. The most important data sources are recreational and commercial mortality estimates, escapement estimates, coded-wire-tag information, mark-rate estimates, and age data. 
In the course of this project we encountered many data issues. Some of these are listed below in hopes of investing additional resources to improve future analyses.

#### Catch Reporting and Accounting
The list of sport and commercial catch reporting issues is generally well known and deserves its own paper. We will not expand on this issue, as there are currently many experts involved in improving the data quality.

For the purpose of the exploitation rate analysis catch is critical to compute coded-wire-tag expansions as the number caught divided by number sampled. Catch is also essential for  calculating exploitation rates in FRAM.

This project was impacted by errors in catch reporting and accounting.

#### Backwards FRAM Data
[Backwards FRAM](#BkFRAM) is conducted to create a post-season validation run using actual catches and escapements. Errors in the source data propagate to the final exploitation rate estimates.

##### Escapement
Stock specific escapements are entered into BkFRAM to reconstruct pre-fishing abundances. We found errors in BkFRAM esacpements and recommend that the recent time-series of post-season runs is updated using 'best escapement' estimates.

##### Mark Rates
BkFRAM has several methods for modeling adipose mark rates. We found errors in mark rates significantly impacting this project, as the analysis was only conducted on marked stock components. We recommend a review of mark rate estimates by regional experts. Special attention should be given to escapements flagged as "2"in BkFRAM. This flagging indicates the use of pre-season mark rates, which were not intensively error checked. 

##### Catch
There were several instances where the modeled landed catch did not match the catch reported to RMIS' Catch/Sample data. Once fisheries mapping issues were ruled out, there still remained a few mismatched fishery catches. On further investigations we found that official catch estimates were updated a couple of years after being published. Therefore, we suggest annually re-querying and updating the most current 2-3 years to populate BkFRAM or conducting periodic reports every 5 years. We also suggest periodically simalr procedures for catches reported to RMIS.

#### Sampling
Accurate sampling data is critical for the integrity of the CWT system, execution of mark-selective fisheries, production of mark rate and catch estimates, and collection of biological information. Hundreds of dedicated samplers annually collect these data, often under difficult circumstances. Several factors can lead to inaccurate results such as sampler error, equipment failure, sampling stratification, low sampling rates, etc. We encountered many instances where sampling was inadequate due to no or insufficient sampling, relying on voluntary tag recoveries, sampling without electronic CWT detection equipment, etc. Additionally, some fisheries, even if well sampled, exhibited highly improbable mark or tag rates. 
Since sampling is the backbone of CWT information flowing into exploitation rate estimates, poor sampling can have a very detrimental effect on these types of analyses.
Perhaps a feedback loop between RMIS and sampling programs could address some of these shortcomings by providing sampling supervisors with annual RMIS summary reports of sampling rates, CWT recoveries and mark rates. 

#### [RMIS Data](#RMIS)
The Regional Mark Information System is the data system where vast amounts of information associated with coded-wire-tags is stored and summarized for the entire West Coast. This project relied heavily on RMIS data. Similar to the catch data, issues associated with RMIS data are generally well known and go beyond the scope of this task, except for some example instances where the data became problematic for this project.
As a general comment we would recommend that RMIS staff conduct intensive training sessions at lease once a year as the complexity of the data is often not suitable for the casual consumer.

##### Release Data (CCT help)
RMIS release data contains information about all salmon releases associated with coded wire tagged fish. The exploitation rate analysis was solely conducted on marked stock. Analysts used the tag codes assigned to marked releases to select the marked FRAM stocks included in the project. However, some of the salmon with tags codes from marked releases were assessed to be predominantly unmarked by field samplers. Either the tag codes were miss-assigned or the adipose clip was insufficient.
Another problem in the release data were fields left blank that would have been important to make stock assignments such as the "Run" field needed to designate a stock as a "Summer" or "Fall" run or "Early" versus "Late".

##### Recovery Data (CCT & DA help)
Every recovered salmon with a coded-wire-tag creates a field in the recovery database. Many deficiencies in the recovery data were caused by sampling issues. This database contains many fields with fairly complex flagging options. There are many pitfalls that can lead an uninformed user to wrong conclusions. For this database in particular user training is highly recommended.
The principal concerns with this database are problematic CWT expansions (see next bullet) and/or missing recoveries. Some entities fail to report their CWT recoveries to RMIS, sometimes resulting in entire fisheries and escapements missing from the database. In the case of missing escapements this can leave a large amount of uncertainty when conducting cohort reconstructions or exploitation rate analyses. 
We also found may instances of errors in recovery data fields, such as the 'adclip_selective_fishery' field, where fisheries were mark-selective fisheries (S) incorrectly flagged as non-selective (N).

##### Catch/Sample Data
The Catch/Sample data is vital to the recovery data as coded-wire-tag sampling expansions are calculated from the data. Inaccurately or non-reported catches or escapements can have a huge impact on CWT analyses.  
Additionally, the stratification used in RMIS can be problematic. Generally RMIS data is stratified by management or statistical  weeks and months, while fisheries are commonly scheduled on a calendar month basis. This can result in miss-alignment of strata. Moreover, un-sampled strata can lead to missing CWT expansions (see [Handling of RMIS Catch/Sample data](#Handling)) and hence missing expanded recoveries.   

#### MSM User Guide and Code Documentation
The [Mixed Stock Model](#MSM) was rewritten in Visual Basic in 2007. Although the document ["Coho FRAM Base Development"](#MSMDoc) descibes the project, the current MSM  lacks code documentation and a user guide, thus requiring a great deal of initiative by a new user to understand the code, the data requirements and re-(run) analyses. 
Although a new program "CohoFRAMModelValidation.Rmd" was written for this project in R Markdown, a [user guide](#MSMGuide) of the MSM was developed during the early stages of this project.

##### Stock Mapping
Mapping hatchery releases to FRAM stocks was one of the most timing consuming tasks of this project. Thorough descriptions of the Coho stocks in FRAM would be extremely beneficial for future stock mapping exercises as well as understanding the stocks in the model. We therefore suggest to compile detailed stock profiles, describing the locations, hatcheries, calibration CWT codes, expansions, associated wild components, modeling parameters, exploitation rate profiles, etc. 

##### Fisheries Mapping
The tasks of mapping RMIS "recovery location codes" and "fisheries" to FRAM fisheries 
was similarly as labor intensive as the stock mapping. We followed the mapping approach from the original MSM to allow future MSM tasks to build on the mapping efforts of this project. As with the stock mapping, developing detailed FRAM fishery profiles is highly recommended.


### Handling of RMIS Catch/Sample data {#Handling}

RMIS Catch/Sample data requires carefully examined before analyzing the
coded-wire-tags associated with a sample. The Catch/Sample data is
stratified into time periods ranging from a few days to several months
depending on the sample design and sample size. Coded-wire tags are
expanded by the ratio of reported catch to sampled catch within a
stratum; i.e., the "Estimated Number" in the CWT recoveries tables
reflects the number of CWTs that would have been recovered if 100% of the
landed catch in a fishery were sampled. Fisheries sampling and catch
reporting can be fraught with many problems and errors such as missing
sampling, missing catch reporting, recording the wrong catch area,
combining samples from more than one fishery, equipment failure, etc. The
following sections describe how the most significant errors were
addressed.

One of the biggest sources of error in tag expansions is introduced when
a stratum with catch is not sampled. RMIS does not address this error by
expanding strata into sampled time periods and recomputing sampling
expansions. This will result in underestimating the CWTs that should have
been recovered had the catch been sampled and consequently result in
exploitation rates that are too low for affected time periods.
Approximately 30% of the 2010-20 Coho catch occurred in unsampled
strata. 

Depending on the fishery and the magnitude of the problem the
following approaches were taken:

#### Exclude Entire Fisheries

Fisheries that were never or rarely sampled were excluded from the
exploitation rate analysis. We also eliminated fisheries that were not
modeled in FRAM. Examples of unmodeled fisheries are some Columbia River
fisheries that are accounted for in regional models rather than in FRAM
or some South of Falcon fisheries that report a small amount of likely
illegal catch. Additionally, all freshwater fisheries were automatically excluded, because they
were frequently not or insufficiently sampled. As these fisheries are
predominately catching the local stock(s), they were of minor informational value for
this analysis. Excluded fisheries were removed from FRAM as well as RMIS.
Table 4.4 contains a list of excluded fisheries and the
principal reason for exclusion (several fisheries were excluded for more than one reason). 

```{r results='asis'}


d_exclude_fish_table<-d_exclude_fish|>
  # gt::gt() |> 
  # # Add title text
  # gt::tab_header(title = "Table 4.1. Fisheries Excluded from CWT Analysis and Main Reason for Exclusion")
 knitr::kable(caption = "Table 4.4.Fisheries Excluded from CWT Analysis and Main Reason for Exclusion") |>
  kableExtra::kable_styling() |>
  kableExtra::scroll_box( width="100%",height = "250px")
  
d_exclude_fish_table
```

#### Recompute the Sampling Expansion

To address unsampled strata, a coefficient was calculated to adjust annual CWT recoveries to the number of recoveries that should have occurred if all the strata had been sampled. This coefficient is referred to as an "Expansion" in Appendix table 9.3. The coefficient is computed by summing the reported RMIS catch over all the strata within a year divided by the sum of the RMIS catch associated with a sampling event.
Appendix table 9.3 contains a summary of FRAM catches, RMIS catches, sampled catches and fishery expansions by fishery and year. The expansions are computed as in below equation. Fisheries or years that are eliminated contain a zero in the "Expansion" row.


$$ AdjustedCWT = EstimatedCWT * \frac {\sum_{strata}NumberCaught}{\sum_{strata}(NumberCaught*b)}$$

Where,    

*   b = 1 if the stratum was sampled and 0 if the stratum was unsampled
*   EstimatedCWT = original expanded for sampling CWT recoveries
*   NumberCaught = Number Caught in RMIS CatchSample database

#### Exclude Years

Years were eliminated for the following reasons:

* FRAM catch less than or equal to 10
* RMIS catch less than or equal to 10
* Catch associated with a sampling event less than or equal to 10
* Large discrepancy between RMIS and FRAM catch. Generally, years were excluded when RMIS and FRAM catch differed by more than 9.5% and 400 fish. 
* Adjustment to sampling expansion greater than 8.
Years were removed from RMIS as well as FRAM (see table 4.2).

#### Combine Fisheries

Some fisheries are conducted in the freshwater as well as the adjacent marine terminal area. The catch or the sampling data for these areas may be reported in one or the other area interchangeably. This was the case for Bellingham Bay and Samish River net (fisheries 97 & 98). Once combined, the FRAM catch closely matched the RMIS catch.

#### Special Cases

**Area 5 sport (fishery 91):** 
For Area 5 sport neither the FRAM modeled catch nor the RMIS catch matched the official Catch Record Card (CRC) estimates. This was likely caused by CRC revisions. However, all strata of this fishery were sampled each year, eliminating the need for a sampling adjustment. For this fishery the CWTs were simply multiplied by the ratio of "FRAM Catch" to "RMIS Catch".  

**Southeast Alaska net (fishery 198):**
The average annual FRAM catch for southeast Alaska of 648,000 was significantly smaller than the RMIS catch of 784,000. Fishery mapping issues were ruled out as a source of the discrepancy. Since the catch associated with sampling was similar to the FRAM catch each year (average 644,000), the CWTs were not adjusted.




# Sensitivity of Exploitation Rates of Key Stocks to Abundance Changes

## Introduction

Many West Coast Coho stocks have overlapping migration paths or natal streams in close proximity to one another. They can therefore be intercepted in the same mixed stock fisheries, where the abundance of one stock can have a pronounced effect on the potential to encounter another stock.

The goal of this project is to evaluate the effects of abundance changes of influential Coho stocks on the exploitation rate of other model stocks to determine which forecasts of abundance have the greatest effect on key wild stocks. Results could be used to inform decision makers about prioritizing the timing and availability of forecast information and allocating limited stock assessment resources.

## Method

The basic method consists of varying the abundances of stock aggregates (test stocks) in the FRAM model, one aggregate at a time, running FRAM, and evaluating mortalities of key wild model stocks (response stocks). For more information about the FRAM model please see [FRAM documentation](https://framverse.github.io/fram_doc/).

The Coho Technical Committee annually produces post-season Coho model runs. These runs start with the final pre-season model run and are subsequently updated with best estimates of stock-specific escapements and post-season assessments of landed and non-landed fisheries mortalities. The most current database is housed on the Pacific Salmon Commission's (PSC) [Extranet website](https://extranet.psc.org/SitePages/Home.aspx). Model runs are updated through 2020 and contained in an Access database called "PSC_CoTC_PostSeason_CohoFRAMDB_thru2020_021622.mdb". 

This evaluation was conducted using post-season Coho model runs (BkFRAM runs) by adjusting stock specific starting Cohorts. Post-season model runs use actual catches and non-retention mortalities; hence fisheries are modeled at fixed values regardless of the abundance of model stocks. Each stock aggregate was modeled at a 'low and a high' abundance.

### Selection of Stocks

The Coho FRAM model contains all West Coast stocks from Alaska to California. For the purpose of this project the influence of abundance changes of pre-selected stock aggregates was evaluated for wild stocks managed under the PST. 

Table 5.1. List of Response Stock Aggregates
<br>
A production region (PR) is comprised of one to several stocks with similar migration paths and exploitation rates.

**Management Unit**|**Short Name**|**Production Region**|**FRAM Stock Name**|**FRAM Stock ID**
:---|:---|:---:|:---|:---
Skagit|Skagit|2|Skagit, Baker|17,23
Stillaguamish/Snohomish|Stilly/Sno|3|Stillaguamish, Snohomish|29, 35
Hood Canal|HC|4|12/12B, 12C/D, Skokomish|45,55,59
Strait of Juan de Fuca|JDF|6|East JDF Misc., West JDF Misc.|115,117
Quillayute|Quill|8|Quillayute|131
Hoh|Hoh|9|Hoh|135
Queets|Queets|10|Queets|139
Grays Harbor|GH|12|Chehalis, Humptulips, Misc. Wild|149,153,157
Georgia Strait Mainland|GSML|17|Georgia Strait Mainland|207
Georgia Strait Vancouver Island|GSVI|18|Georgia Strait Vancouver Island|211
Lower Fraser|LwFraser|22|Lower Fraser|227
Upper Fraser|UpFraser|23|Upper Fraser|231

Test stocks were selected based on origin and likelihood of affecting response stocks. 

Table 5.2. List of Test Stock Aggregates

```{r echo = FALSE, results='asis'}
# **Management Unit**|**Short Name**|**Production Region**|**FRAM Name**|**FRAM ID**
# :---|:---|:---:|:---|:---:
# Nooksack/Samish|NOSA|1|Nooksack Wild, Kendall Hat, Skookum Hat, Lummi Ponds, Bellingham Bay Net Pens, Samish Wild, 7-7A Independent Wild, Whatcom Hat|1-16
# Skagit|Skagit|2|Skagit Wild, Skagit Hat, Baker Wild, Baker Hat, Swinomish Hat, Oak Harbor Net Pens|17-28
# Stillaguamish/Snohomish|Stilly/Sno|3|Stilly Hat, Stilly Wild, Tulalip Hat, Sno Wild, Sno Hat, 8A Net Pens|29-40
# Hood Canal|HC|4|Port Gamble Net Pens, Port Gamble Wild, 12/12B Wild, Quilcene Hat, Quilcene Net Pens, 12A wild, Hoodsport Hat, 12C/12D Wild, George Adams Hat, Skokomish Wild|41-60
# South Puget Sound|SPS|5|13B Misc Wild, Deschutes, SPS Net Pens, Nisqually Hat, Nisqually Wild, Fox Is. Net Pens, Minter Hat, 13 Misc Wild, 13 Misc Wild, 13Misc Hat, Chambers Hat, 13A Misc Wild, Puyallup Hat, Puyallup Wild, 11 Hat, 11 Misc Wild, 10E Hat, 10E Misc Wild, Green Hat, Green Wild, Lk Washington Hat, Lk Washington Wild, 10 Hat, 10 Misc Wild|61-106
# Strait of Juan de Fuca|JDF|6|Elwah Wild, Dungeness Wild, East JDF Misc Wild, West JDF Misc. Wild, Port Angeles Net Pens, 9 Misc Wild|107-122
# Quillayute|Quill|8|Quillayute Summer Wild, Quillayute Summer Hat,Quillayute Fall Wild,Quillayute Fall Hat|127-134
# Hoh|Hoh|9|Hoh Wild, Hoh Hat|135-138
# Queets|Queets|10|Queets Fall Wild, Queets Fall Hat, Queets Suppl. Hat|139-144
# Grays Harbor|GH|12|Chehalis Wild, Chehalis Hat, Humptulips Wild, Humptulips Hat, GH Misc Wild, GH Net Pens|149-160
# Georgia Strait Mainland|GSML|17|Georgia Strait Mainland Hatchery and Wild|205-208
# Georgia Strait Vancouver Island|GSVI|18|Georgia Strait Vancouver Island Hatchery and Wild|209-212
# SW Vancouver Island|SWVI|20|SW Vancouver Island Hatchery and Wild|217-220
# Lower Fraser|LwFraser|22|LwFraser Hat, LwFraser Wild|225-228
# Upper Fraser|UpFraser|23|UpFraser Hat, UpFraser  Wild|229-232

table2_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_2_section1c.xlsx"))

reactable::reactable(table2_1c,
                     bordered = TRUE,
                     striped = TRUE,
                     height = 500,
                     showPageSizeOptions = TRUE,
                     defaultPageSize = 20,
                     pageSizeOptions = c(10, 20, 50, 100),
                     highlight = TRUE,
                     defaultColDef = reactable::colDef(vAlign = "center", 
                                                       headerVAlign = "bottom", 
                                                       align = "center", 
                                                       headerStyle = list(background = "#f7f7f8")),
                     columns = list(
                       `Management Unit` = reactable::colDef(minWidth = 120),
                       `Short Name` = reactable::colDef(minWidth = 80),
                       `Production Region` = reactable::colDef(minWidth = 95),
                       `FRAM Name` = reactable::colDef(minWidth = 350),
                       `FRAM ID` = reactable::colDef(minWidth = 80)
                     )
                    )
```
<br>

### Selection of Fishing Years

This project focused on recent 2010-2018 fishing years, because recent years are most pertinent to current environmental conditions and because this time series has been extensively error checked. 2013 was selected to represent a 'high' run size year and 2015 to represent a 'low' year. The aggregate starting Cohort abundances for test stocks was 2,240,000 million and 760,000 respectively. The remaining years were solely used to calculate average starting abundances, but not to run the actual simulations (see description under Model Runs).

### Selection of Low and High Abundances

For each stock within a production region (Table 5.1) the low abundance was set at 30% and the high abundance at 170% of the 2010-2018 average Starting Cohort. Starting Cohorts are abundances pre fishing and pre natural mortality. Lows and highs were chosen to be equidistant from the average. This limited the range, as abundances below 30% of average could result in negative escapements given the fisheries in the 2013 and 2015 model runs.

Table 5.3. 2010 to 2018 starting Cohorts of Coho test stocks, including average, low (30% of average) and high (170% of average) Starting Cohorts for each test stock. In FRAM abundances are modeled using stock recruit scalers. These scalers linearly relate the abundance in a given year to the abundance in FRAM base period years. 

```{r echo = FALSE, results = 'asis'}
table3_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_3_section1c.xlsx"))

reactable::reactable(table3_1c,
                     bordered = TRUE,
                     striped = TRUE,
                     height = 500,
                     showPageSizeOptions = TRUE,
                     defaultPageSize = 20,
                     pageSizeOptions = c(10, 20, 50, 100),
                     highlight = TRUE,
                     columns = list(
                       PR = reactable::colDef(minWidth = 40, sticky = "left"),
                       `Stock ID` = reactable::colDef(minWidth = 60, sticky = "left"),
                       `2010` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2011` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2012` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2013` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2014` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2015` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2016` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2017` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       `2018` = reactable::colDef(minWidth = 70,
                                                  format = reactable::colFormat(separators = TRUE)),
                       Average = reactable::colDef(minWidth = 75,
                                                   style = list(background = "#ADE6D1"),
                                                   format = reactable::colFormat(separators = TRUE)),
                       `Low (30%)` = reactable::colDef(minWidth = 70,
                                                       style = list(background = "#E6BFAD"),
                                                       format = reactable::colFormat(separators = TRUE)),
                       `High (170%)` = reactable::colDef(minWidth = 70,
                                                         style = list(background = "#E6BFAD"),
                                                         format = reactable::colFormat(separators = TRUE)),
                       `Low Stock Recruit` = reactable::colDef(minWidth = 70,
                                                               style = list(background = "#ADD8E6"),
                                                               format = reactable::colFormat(digits = 3)),
                       `High Stock Recruit` = reactable::colDef(minWidth = 70,
                                                                style = list(background = "#ADD8E6"),
                                                                format = reactable::colFormat(digits = 3))
                     ),
                     defaultColDef = reactable::colDef(vAlign = "center", 
                                                       headerVAlign = "bottom", 
                                                       align = "center", 
                                                       headerStyle = list(background = "#f7f7f8"))
                    )
```

### Model Runs

Abundances of stock aggregates were adjusted one production region at a time. Each stock within a production region was modeled at a low (30% of average) and at a high (170% of average) abundance. This was done for the 2013 as well as the 2015 post-season runs, resulting in a total of 64 model runs (16 production regions * 2 years * 2 abundance levels). Appendix table 9.7 contains a list of model runs.

To avoid negative escapements, extreme terminal and freshwater fisheries were set to zero. These fisheries predominantly intercept local stocks with minimal interference from other test stocks; thus, providing little relevance to the sensitivity analysis.

Appendix table 9.8 contains a list of fisheries set to zero in the model runs.

Additionally, several fisheries were modified for individual run pairs (low/high pairs) to avoid negative escapements.

Table 5. List of model runs, fisheries, and time steps with catch reductions to avoid negative escapements

**Model Run ID**|**ID**|**Fishery**|**Time Step**|**New Catch**
:---:|:---:|:---:|:---:|:---:
43, 44|160|A 12C-12D Treaty Net|5|2,000
69, 70|107|A 9 Sport (Admirality Inlet)|4|10,000
||118|A 10 Sport (Seattle)|4|5,000
91, 92|96|A 7B-7C-7D Non-Treaty Net|4|10,000
||97|A 7B-7C-7D Treaty Net|4|10,000
93/94, 97/98, 99/100|144|A 13D Treaty Net|4|2,000
||144|A 13D Treaty Net|5|2,000

## Analysis of Results

After running the FRAM model, total fisheries related mortalities and escapements from response stocks were extracted from the Access database to compute exploitation rates. For each model run, mortalities and escapements were summed over all response stocks within a production region (PR).

Equation 1:

$$ExploitationRate_{PR} = \frac{\sum_{stk \in PR}Mortalities}{\sum_{stk \in PR}Mortalities + \sum_{stk \in PR}Escapement}$$

This resulted in four exploitation rates (2013 Low, 2013 High, 2015 Low, 2015 High) per production region.

## Results

The magnitude of the exploitation rate difference between low (abundance at 30% of average) versus high (abundance at 170% of average) test stock abundances, henceforth referred to as the 'effect', is a function of two factors, (1) the test stock abundance and (2) overlapping fisheries distributions. A test stock aggregate with a high abundance will affect the response stock to a greater degree than one with a low abundance. If the test stock and result stock have a similar distribution in key fisheries, the effect will also be greater.

Equation 2: The "effect is calculated as:

$$ER_{TestStockLow} - ER_{TestStockHigh}$$

Results are displayed in three tables (Tables 5.6-5.8) and three graphs (Figures 5.1-5.3).

Table 5.6 displays the exploitation rates of key wild response stock resulting from varying the abundances of test stocks. Results are presented for every test/response stock combination in the 2013 and 2015 post-season runs. Exploitation rates from table 5.6 are graphed in Figure 5.1 with different color bars for 'Low' and 'High' test stock abundances for the 2013 and 2015 run years (4 bars per response stocks). Each test stock is displayed as a separate panel in the graph. Table 5.7 summarizes detailed results from table 5.6 by presenting only exploitation rate differences (as calculated in equation 2). Differences are averaged over 2013 and 2015 run years. Figure 5.2 displays exploitation rate differences from table 5.6 with different color bars for the 2013 and 2015 run years (2 bars per response stock). Each test stock is displayed as a separate panel in the graph. Figures. Table 5.8 lists the top five fisheries responsible for exploitation rate differences of notable test/response stock combinations, i.e., test stocks with a significant or otherwise notable impact on response stocks.

Table 5.6. Exploitation rates of key wild response stock resulting from varying abundance of test stocks. “Low” denotes test stock abundance at 30% of average and “High” at 170% of average. Run year 2013 represents a high abundance year, and 2015 a low abundance year. The columns “Diff” display the difference in response stock exploitation rates resulting from varying the abundance of test stocks in the 2013 and 2015 model run. The column 'Avg Diff' averages 2013 and 2015 differences.

```{r echo = FALSE, results = 'asis'}
table6_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_6_section1c.xlsx"), range = "A2:K194")

reactable::reactable(table6_1c |> 
                     dplyr::rename(`Stock ID` = `Stk ID`),
                     bordered = TRUE,
                     striped = TRUE,
                     height = 500,
                     showPageSizeOptions = TRUE,
                     defaultPageSize = 20,
                     pageSizeOptions = c(10, 20, 50, 100),
                     highlight = TRUE,
                     defaultColDef = reactable::colDef(vAlign = "center", 
                                                       headerVAlign = "bottom", 
                                                       align = "center",
                                                       headerStyle = list(background = "#f7f7f8")),
                     columnGroups = list(
                       reactable::colGroup(name = "Test Stock", 
                                           columns = c("PR #", "PR Name")),
                       reactable::colGroup(name = "Response Stock", 
                                           columns = c("Stock ID", "Stock Name")),
                       reactable::colGroup(name = "Exploitation Rates", 
                                           columns = c("2013 Low", "2013 High",
                                                       "2015 Low", "2015 High",
                                                       "2013 Diff", "2015 Diff",
                                                       "Avg Diff"))
                     ),
                     columns = list(
                       `PR #` = reactable::colDef(minWidth = 70, filterable = TRUE, sticky = "left"),
                       `PR Name` = reactable::colDef(minWidth = 120, filterable = TRUE, sticky = "left"),
                       `Stock ID` = reactable::colDef(minWidth = 85, filterable = TRUE, sticky = "left"),
                       `Stock Name` = reactable::colDef(minWidth = 130, filterable = TRUE, sticky = "left"),
                       `2013 Low` = reactable::colDef(minWidth = 95, sortable = TRUE,
                                                      format = reactable::colFormat(percent = TRUE, digits = 2)),
                       `2013 High` = reactable::colDef(minWidth = 97, sortable = TRUE,
                                                      format = reactable::colFormat(percent = TRUE, digits = 2)),
                       `2015 Low` = reactable::colDef(minWidth = 95, sortable = TRUE,
                                                      format = reactable::colFormat(percent = TRUE, digits = 2)),
                       `2015 High` = reactable::colDef(minWidth = 97, sortable = TRUE,
                                                       format = reactable::colFormat(percent = TRUE, digits = 2)),
                       `2013 Diff` = reactable::colDef(minWidth = 95, sortable = TRUE,
                                                       style = list(background = "#D3D3D3"),
                                                       format = reactable::colFormat(percent = TRUE, digits = 2)),
                       `2015 Diff` = reactable::colDef(minWidth = 95, sortable = TRUE,
                                                       style = list(background = "#D3D3D3"),
                                                       format = reactable::colFormat(percent = TRUE, digits = 2)),
                       `Avg Diff` = reactable::colDef(minWidth = 95, sortable = TRUE,
                                                      style = list(background = "#A9A9A9"),
                                                      format = reactable::colFormat(percent = TRUE, digits = 2))
                     ),
                     defaultSorted = list(`PR #` = "asc"),
                     rowStyle = reactable::JS("
                      function(rowInfo, state) {
                        // Ignore padding rows
                        if (!rowInfo) return
                  
                        // Add horizontal separators between groups when sorting by school
                        const firstSorted = state.sorted[0]
                        if (firstSorted && firstSorted.id === 'PR #') {
                          const nextRow = state.pageRows[rowInfo.viewIndex + 1]
                          if (nextRow && rowInfo.values['PR #'] !== nextRow['PR #']) {
                            // Use box-shadow to add a 2px border without taking extra space
                            return { boxShadow: 'inset 0 -2px 0 rgba(0, 0, 0, 0.1)' }
                          }
                        }
                      }
                    ")
)
```

Table 5.7. Average exploitation rate differences of key wild response stocks resulting from varying the abundances of test stocks. The purple bars display the relative magnitude of the effect on 'foreign' stocks, whereas blue bars show the relative magnitude of the effect on 'home' stocks belonging to the same production unit as the test stock. Green shading is used if test and response stock belong to the same country, yellow for US test stocks on Canadian response stocks or vice versa. The yellow bars on the last row index production region abundances to the largest (South Puget Sound (SPS)) stock; i.e. average 2010-18 abundance of production region divided by average SPS production region abundance.

```{r echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
table7_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_7_section1c.xlsx"))

library(tidyverse)

table7_1c %>% 
    dplyr::mutate(
        nooksambarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          TRUE ~ "#FF0000A0"
          ),
        skagitbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("skagit", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        stillysnobarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("stilly", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        hcbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("hood canal", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        spsbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          TRUE ~ "#FF0000A0"
          ),
        jdfbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("jdf", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        quillbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("quill", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        hohbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("hoh", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        queetsbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("queets", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        quinbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          TRUE ~ "#FF0000F0"
          ),
        ghbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("gh", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        gsmlbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("gsml", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        gsvibarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("gsvi", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        swvibarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          TRUE ~ "#FF0000A0"
          ),
        lwfrasbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("lw fras", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
        upfrasbarcol = dplyr::case_when(
          `Response Stock` == "Abundance Index" ~ "#FFD700",
          grepl("up fras", tolower(`Response Stock`)) ~ "#0000FF80",
          TRUE ~ "#FF0000A0"
          ),
    ) %>% reactable::reactable(., 
                   defaultPageSize = 13,
                   highlight = TRUE,
                   bordered = TRUE,
                   defaultColDef = reactable::colDef(
                       align = "center",
                       headerStyle = list(background = "#f7f7f8")
                   ),
                   columns = list(`Response Stock` = reactable::colDef(minWidth = 145,
                                                                       align = "left",
                                                                       sticky = "left",
                                                                       style = function(value, index){
                                                                         if(value == "Abundance Index"){
                                                                           list(fontWeight = "bold")
                                                                         }
                                                                       }),
                                    `Nook Samish` = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "nooksambarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    Skagit = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                    },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "skagitbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120), 
                                    `Stilly Sno` = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "stillysnobarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    `Hood Canal` = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "hcbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    SPS = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "spsbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    JDF = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "jdfbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    Quill = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "quillbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    Hoh = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "hohbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    Queets = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "queetsbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    Quinault = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "quinbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    `Grays Harbor` = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#8FBC8F")  
                                        } else if(index %in% 9:12){
                                          list(background = "#FFFACD")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "ghbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    GSML = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#FFFACD")  
                                        } else if(index %in% 9:12){
                                          list(background = "#8FBC8F")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "gsmlbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    GSVI = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#FFFACD")  
                                        } else if(index %in% 9:12){
                                          list(background = "#8FBC8F")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "gsvibarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    SWVI = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#FFFACD")  
                                        } else if(index %in% 9:12){
                                          list(background = "#8FBC8F")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "swvibarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    `Lw Fraser` = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#FFFACD")  
                                        } else if(index %in% 9:12){
                                          list(background = "#8FBC8F")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "lwfrasbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    `Up Fraser` = reactable::colDef(style = function(value, index){
                                        if (index < 9){
                                           list(background = "#FFFACD")  
                                        } else if(index %in% 9:12){
                                          list(background = "#8FBC8F")
                                        } else{
                                          list(background = "none")
                                        }
                                      },
                                      cell = reactablefmtr::data_bars(.,
                                                       text_position = "inside-base",
                                                       brighten_text = FALSE,
                                                       max_value = 1,
                                                       min_value = -0.01,
                                                       background = "#D3D3D380",
                                                       fill_color_ref = "upfrasbarcol",
                                                       number_fmt = scales::label_percent(accuracy = 0.1)),
                                      minWidth = 120),
                                    nooksambarcol = reactable::colDef(show = FALSE),
                                    skagitbarcol = reactable::colDef(show = FALSE),
                                    stillysnobarcol = reactable::colDef(show = FALSE),
                                    hcbarcol = reactable::colDef(show = FALSE),
                                    spsbarcol = reactable::colDef(show = FALSE),
                                    jdfbarcol = reactable::colDef(show = FALSE),
                                    quillbarcol = reactable::colDef(show = FALSE),
                                    hohbarcol = reactable::colDef(show = FALSE),
                                    queetsbarcol = reactable::colDef(show = FALSE),
                                    quinbarcol = reactable::colDef(show = FALSE),
                                    ghbarcol = reactable::colDef(show = FALSE),
                                    gsmlbarcol = reactable::colDef(show = FALSE),
                                    gsvibarcol = reactable::colDef(show = FALSE),
                                    swvibarcol = reactable::colDef(show = FALSE),
                                    lwfrasbarcol = reactable::colDef(show = FALSE),
                                    upfrasbarcol = reactable::colDef(show = FALSE)
                                  )
                                )
```

Figure 5.1. Exploitation rates of key wild stocks resulting from varying the abundance of test stocks. Figure has separate paneles for each test stock. Response stocks are graphed along the x-axis. The exploitation rate for each response stock is plotted for the four modeling scenarios (2013Low/High, 2015Low/High)


```{r}
#Read in results of Senstivity Analysis
SenA.Results=read.csv(paste0(table_dir,"SA_Results - Copy.csv"))
SenA.Results<-data.frame(SenA.Results)
#eliminate columns that are not needed
SenA.Results1<-SenA.Results[,-c(9:11)]
#reformat, turning columns into rows

SenA.Results1<-reshape::melt(SenA.Results1, id=c(1:2,7:8))
colnames(SenA.Results1)[5]<-"Run"
colnames(SenA.Results1)[6]<-"Expl.Rate"
p<-ggplot(SenA.Results1,aes(Result, Expl.Rate))
#produce graphs; facet command results in one graph per Adjusted.Abundance"
SenA.Graph1<-p+geom_bar(stat = "identity",aes(fill=Run), position="dodge")+
  xlab("Response Stock")+ylab("Expl.Rate")+ggtitle ("Exploitation Rate as Function of Abundance")+ 
  theme(axis.text.x = element_text(angle = 90),legend.position = "bottom")+ facet_wrap( ~ Adjusted.Abundance )+
  scale_fill_manual(values=c("bisque","burlywood1","cadetblue1","cadetblue3"),
  labels =c("2013 Low", "2013 High", "2015 Low", "2015 High"))
SenA.Graph1
#produce output
#ggsave("SenA.Graph1.png",width=8, height=10)


```


Figure 5.2. Y-Axis equal for all paneles. Exploitation rate differences resulting from varying the abundances of test stocks from high to low. Figure has separate paneles for each test stock. Response stocks are graphed along the x-axis. The exploitation rate differences for each response stock are plotted for 2013 and 2015 run years. Graph is excluding scenarios where test and response stocks are equal.

```{r}

"produce second graph of ER differences"
SenA.Results2<-SenA.Results
SenA.Results2<-SenA.Results2[,-c(3:6,11)]
SenA.Results2<-reshape::melt(SenA.Results2, id=(1:4))
colnames(SenA.Results2)[6]<-"ER.Diff"
colnames(SenA.Results2)[5]<-"Run"
#Set rows to zero if reponse stock = adjusted.abundance stock to avoid unreadable y axis"
a<-index<-SenA.Results2$Stk1==SenA.Results2$Stk2
SenA.Results2$ER.Diff[index]<-0
SenA.Results2

# q=ggplot(SenA.Results2,aes(Result, ER.Diff))
# SenA.Graph2<-q+geom_bar(stat = "identity",aes(fill=Run), position="dodge")+
#            xlab("Response Stock")+ylab("Expl.Rate Difference")+
#            ggtitle ("Exploitation Rate Difference as Function of Abundance")+ 
#            theme(axis.text.x = element_text(angle = 90), legend.position = "bottom")+ facet_wrap( ~ Adjusted.Abundance, scales="free_y")+
#            scale_fill_manual(values=c("burlywood1","cadetblue3"),
#                              labels =c("2013 Diff", "2015 Diff"))
# SenA.Graph2
#jpeg("SenAExplRateGraph2.jpg")   
#SenA.Graph2
#dev.off()
#ggsave("SenA.Graph2.png",width=8, height=10)

q=ggplot(SenA.Results2,aes(Result, ER.Diff))
SenA.Graph2<-q+geom_bar(stat = "identity",aes(fill=Run), position="dodge")+
  xlab("Response Stock")+ylab("Expl.Rate Difference")+
  ggtitle ("Exploitation Rate Difference as Function of Abundance")+ 
  theme(axis.text.x = element_text(angle = 90), legend.position = "bottom")+ facet_wrap( ~ Adjusted.Abundance)+
  scale_fill_manual(values=c("burlywood1","cadetblue3"),
                    labels =c("2013 Diff", "2015 Diff"))
SenA.Graph2

#ggsave("SenA.Graph3.png",width=8, height=10)
```


Table 5.8. Top 5 fisheries responsible for total mortality differences caused by varying the abundances of test stocks. Table only displays difference for test/response stock combinations with notable differences. Difference is calculated as the average 2013 and 2015 difference in mortalities between low and high abundances of test stocks.

```{r echo = FALSE, message = FALSE, warning = FALSE, results='asis'}
table8_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_8_section1c.xlsx"))

reactable::reactable(table8_1c,
                     defaultColDef = reactable::colDef(vAlign = "center", 
                                                       headerVAlign = "bottom", 
                                                       align = "center",
                                                       minWidth = 150,
                                                       headerStyle = list(background = "#f7f7f8")),
                     highlight = TRUE,
                     outlined = TRUE,
                     height = 500,
                     showPageSizeOptions = TRUE,
                     defaultPageSize = 20,
                     pageSizeOptions = c(10, 20, 50, 100),
                     columns = list(
                      `Test Stock` = reactable::colDef( 
                        style = reactable::JS("function(rowInfo, column, state) {
                          const firstSorted = state.sorted[0]
                          // Merge cells if unsorted or sorting by school
                          if (!firstSorted || firstSorted.id === 'Test Stock') {
                            const prevRow = state.pageRows[rowInfo.viewIndex - 1]
                            if (prevRow && 
                              rowInfo.values['Test Stock'] === prevRow['Test Stock'] && 
                              rowInfo.values['Response Stock'] === prevRow['Response Stock']) {
                                return { visibility: 'hidden' }
                            }
                          }
                        }")
                      ),
                      `Response Stock` = reactable::colDef( 
                        style = reactable::JS("function(rowInfo, column, state) {
                          const firstSorted = state.sorted[0]
                          // Merge cells if unsorted or sorting by school
                          if (!firstSorted || firstSorted.id === 'Response Stock') {
                            const prevRow = state.pageRows[rowInfo.viewIndex - 1]
                            if (prevRow && 
                              rowInfo.values['Test Stock'] === prevRow['Test Stock'] && 
                              rowInfo.values['Response Stock'] === prevRow['Response Stock']) {
                                return { visibility: 'hidden' }
                            }
                          }
                        }")
                      )
                     )
)
```

## Discussion

Two run years were selected to evaluate the effects of abundance changes of individual stock aggregates (test stocks) on key wild stocks (response stocks). The abundance of the test stock aggregate varied between 0.3 and 1.7 of the average abundance. Examining two run years, doubled the number of model runs, but added valuable information about the sensitivity of abundance effects to fishing conditions and run sizes during generally low (2015) versus high (2013) abundance years. The exploitation rate difference was on average 2.6 times greater during the low abundance year. The nature of exploitation rate calculations and post-season model run inputs, results in unidirectional exploitation rate changes; i.e., exploitation rates of response stocks are always higher when the test stock is at low abundance  For almost all scenarios the exploitation rate difference was greater for the 2015 post-season run (low abundance year); i.e., the same response stock catch increase caused by a lower test stock abundance results in a higher exploitation rate when the denominator (abundance of the response stock) is lower. For the few test/response stock combinations where this didn't apply, having higher exploitation rate differences during high abundance years was usually the result of a few key fisheries that were much larger in 2013 than in 2015.

Key Points:

- Nooksack/Samish: This stock aggregate has a considerable impact on Canadian stocks, especially Lower Fraser (9%). The Nooksack/Samish Coho stock is fairly large and has substantial overlap with other stocks in large Coho fisheries. Nooksack/Samish Coho abundance is also important for Skagit (6.6%), Hood Canal (4.1%), and JDF (2.5%) exploitation rates.
- Skagit, Stillaguamish, Snohomish: These stocks have a relatively small effect on Canadian stocks (1.1%-1.8%) but can have a significant effect on Hood Canal Coho (4.8%, 7.7%) and each other; i.e., Stilly/Sno on Skagit (6%). 
- Hood Canal and South Puget Sound: These two stock aggregates are important contributors to several large fisheries. Their abundances can have a significant effect on Skagit, Stillaguamish/Snohomish, U.S. Strait of Juan de Fuca as well as Lower and Upper Fraser stocks. These two stocks also substantially affect each other. Although South Puget Sound Coho are not tracked as part of US/Canada agreements, due to its size this stock aggregate plays an important role in exploitation rate outcomes of wild stocks monitored under the treaty. 
- U.S Strait of Juan de Fuca: This stock aggregate has a small effect on other U.S and Canadian stocks, mainly due to it low abundance.
- U.S. Coastal Stocks (Quillcene, Hoh, Queets, Quinault, Grays Harbor): Due to their distribution, these stocks have a small effect on Puget Sound and Canadian stocks but can have a large effect on each other.
- Georgia Strait (Mainland and Vancouver Island): Due to their relatively small abundances, these stocks have a fairly small effect on Puget Sound and Coastal stocks, yet can have a pronounced effect on Lower Fraser stocks (3.1% and 2.3% respectively)
- South West Vancouver Island: This stock's abundances can have a significant effect (1.3%) on the Queets wild stock. Queets is a frequent limiter of U.S. ocean and coastal fisheries. This effect is due in large part to overlapping distribution in the West Coast Vancouver Island sport fishery. This stock aggregate also has a 1.2% exploitation rate effect on Skagit and a 1.4% effect on Hood Canal stocks.
- Lower Fraser: Of the Canadian stocks tested, the Lower Fraser stock aggregate has the greatest effect on U.S. stocks, in particular Skagit, Hood Canal, and Strait of Juan de Fuca stocks. The abundance of the Lower Fraser stock aggregate also significantly impacts Upper Fraser (4.2%) and Georgia Strait stocks (7.6%).
- Upper Fraser: This stock aggregate has a relatively small effect on Puget Sound and Coastal stocks (0.2%-0.8%) as well as Canadian stocks (1.4%-1.5%).
- The following 7 fisheries are listed over 70% in the top 5 categories (Table 5.8):
  - Area 5 Sport
  - WCVI Sport
  - Area 6 Sport
  - Area 4/4B Treaty Troll
  - Area 9 Sport
  - 6/7/7A Net Tr
  - BC JDF Sport

Except for Lower Fraser, the Canadian Coho stocks included in the Pacific Salmon Treaty have a relatively minor effect on the exploitation rates of U.S. Puget Sound and Coastal stocks.

Several of the Puget Sound stocks have a significant effect on Canadian stocks, as well as other Puget Sound stocks, in particular Nooksack/Samish, Hood Canal, and South Puget Sound stock aggregates.

Investing in improved forecast assessments to improve the accuracy of FRAM exploitation rate estimates would be most beneficial for Nooksack/Samish, Hood Canal, South Puget Sound, and Lower Fraser Coho stocks. 


# Comparison of Fishery Adipose Mark Rates from FRAM Validation Runs to Mark Rates from Sampling

## Introduction

In the nineties, the Washington Department of Fish and Wildlife (WDFW)
began to remove the adipose fin of most hatchery Coho and Chinook
salmon, a practice referred to as mass-marking. A missing adipose fin
became a visual indicator for a hatchery salmon, enabling anglers to
distinguish a wild from a hatchery fish. Subsequently, the Department
introduced mark-selective fisheries (MSF) as a fisheries management
tool. In MSFs, salmon with a missing adipose fin (marked) can be
retained, while salmon with an intact fin (unmarked) must be released,
thus reducing the impact on wild salmon.

A fishery mark rate is calculated as the number of marked salmon divided
by all the salmon (marked + unmarked) in a fishery.

Mark rates are an indirect measure of the Fisheries Regulation and
Assessment Model's (FRAM) ability to accurately predict fishery stock
composition and stock abundances. If modeled mark rates deviate
significantly from observed mark rates, assessments of mortalities on
hatchery and wild components of a stock will be incorrect.

A 2011 study conducted by Robert Cope (Cope 2011) found that pre-season
FRAM consistently overestimates fishery mark rates, resulting
in too few unmarked/wild mortalities. The study speculates on
forecasting error as the cause.

This project uses mark rates from post-season model runs, thus
eliminating forecast error as a possible source. Mark rates from
post-season FRAM runs, using reconstructed Coho abundances, are either
compared to mark rates reported to the Regional Mark Information System
(RMIS) for non-selective fisheries or to mark rates of encounters
(retained plus released Coho) from sampling programs for mark-selective
fisheries.

## Method

For this study, mark rates from 2010- 2018 FRAM were compared to mark
rates from fishery sampling programs. Most Coho fisheries along the
American West Coast are sampled by fishery technicians (samplers). For
many sport fisheries, samplers inspect the landed (retained) catch for
the presence of an adipose mark. They also interview anglers about the
mark status of released fish, allowing the calculation of a mark rate of
Coho encounters (landed plus released). This is important, as the mark
rate of the landed catch in mark-selective fisheries is almost 100% by
design. For most commercial fisheries, the sampling programs only report
the mark status of the landed catch, because the mark-status of released
Coho is rarely enumerated on commercial vessels. Therefore, this study
only evaluates the landed mark rate in non-selective commercial
fisheries.

Fishery sampling programs along the entire West Coast report adipose
mark information to the Regional Mark Information System (RMIS). RMIS
houses fishery catch, sampling, and coded-wire-tag (CWT) information.
RMIS' "CatchSample" data provides a one-stop-shop for coast-wide mark
rate information. For this analysis adipose mark rate information was
downloaded from
[RMIS](https://www.rmis.org/cgi-bin/queryfrm.mpl?Table=catch_sample&Version=4.1).

RMIS adipose mark rates are only reported for landed catches. Mark rates
for mark-selective fisheries were provided by data stewards from
Washington State's ocean and Puget Sound sampling programs. For
mark-selective sport fisheries, these programs collect additional
information on the number and mark-status of released salmon that permit
the computation of the mark rate of encounters.

FRAM is a computer simulation model developed for fishery management and
used to estimate the impacts of Pacific Coast salmon fisheries on
Chinook and Coho stocks. FRAM mark rates are model projections using
historical stock-/fishery-specific exploitation rates in combination
with post-season estimates of fishery mortalities and stock-specific
abundances (see [FRAM
documentation](https://framverse.github.io/fram_doc/)).

FRAM fishery adipose mark rates were either compared to mark rates that
came directly from sampling programs or mark rates from RMIS.
Additionally, a comparison between adipose mark rates from sampling
programs, the primary data source, with mark rates from RMIS, the
secondary data source, was also conducted to assess whether the data
manipulations performed to import sampling data into RMIS can result in
significant differences.

The entire mark rate analysis was conducted in R Markdown by a program
named "CohoFRAMModelValidation.Rmd".

```{r table example, include = TRUE, results='asis'}
# Save table information as a tibble
dplyr::tibble(`Source 1` = c("FRAM", "FRAM", "RMIS"),
       `Source 2` = c("RMIS", "Sampling", "Sampling"),
       Fisheries = c("Non-selective sport and commercial fisheries",
                     "Mark-selective sport fisheries",
                     "Non-selective sport and commercial fisheries")
       ) |> 
  # Format as a table
  gt::gt() |> 
  # Make column headers bold
  gt::cols_label(.list = list(`Source 1` = gt::md("**Source 1**"), 
                              `Source 2` = gt::md("**Source 2**"),
                              Fisheries = gt::md("**Fisheries**"))) |> 
  # Add title text
  gt::tab_header(title = "Table 6.1. Sources for Mark Rate Comparisons by Fishery Type")
```

### General Data Manipulations

For compatibility purposes, all three data sources underwent the
following data manipulations:

**Limit Data to Run Years 2010 to 2018** <br>
The data analysis was limited to run years 2010 to 2018. Post-season FRAM data after 2009 has received additional vetting. The limitation to 2018 was due to incomplete data reporting post 2018 at the beginning of this project.

**Eliminate sampling estimates with fewer than 20 observations per time step** <br>
RMIS and sampling program estimates were removed from the analysis if fewer than 20 Coho were sampled per time step. 

**Sum Over Time Steps** <br>
Landed catch and encounter data was summed over time steps within
a year. Coho FRAM is stratified into 5 time steps ranging from 1 month
to 6 months in duration (see Appendix 9.10). Almost all the analyses are
conducted on annual data to avoid slight differences in time step
definitions between RMIS and FRAM and to increase the power of the
evaluations.

**Combine Treaty/Non-treaty Net Fishery Pairs** <br>
In FRAM, most net fisheries exists in treaty, non-treaty pairs; i.e., Area 10 treaty and Area 10 non-treaty net. Differentiating a treaty from a non-treaty net fishery in RMIS is often not possible. Additionally, since these
fisheries occur in the same geographic area with similar gear, they
should experience similar mark rates. Therefore, catch information from
treaty/non-treaty fishing pairs was summed for FRAM and sampling
analyses. See Appendix 9.9 for a list of fishery pairs.

**Wilcoxon signed-rank test** <br>
The Wilcoxon signed-rank test is a
non-parametric hypothesis test. Similar to the Student's t-test, it is a
paired difference test. It can be a good alternative to the t-tests when
results are not normally distributed. This test was used to compare mark
rates from FRAM and sampling. P-values smaller than 0.05 were selected to be statistically significant; i.e., FRAM mark rates are significantly different from sampling mark rates. The test was applied to annual mark rates for fisheries with at least 5 years of data. It was run as a "paired" test.

### Mark Rates from Sampling

Mark rates from Washington ocean areas 1-4 and Puget Sound fisheries
were provided by the data stewards of the Ocean and Puget Sound Sampling
Programs in January of 2022. The number of marked landed, unmarked
landed, marked releases, and unmarked released were pre-summarized by
fishery, year, and month.

Calculation of mark rates from landed catch: Equation 1: $$
MarkRate_{Landed} = \frac{Marked_{Landed}}{Marked_{Landed}+Unmarked_{Landed}}$$

Calculation of mark rates from encounters: Equation 2: $$
MarkRate_{Encounters} = \frac{Marked_{Landed}+Marked_{Released}}{Marked_{Landed}+Unmarked_{Landed}+Marked_{Released}+Unmarked_{Released}}
$$ 
For each fishery and year combination numbers of Marked_Landed,
Unmarked_Landed, Marked_Released and Unmarked_Released were first summed
over months withing a time step and subsequently summed over time steps
within a year. Release information was only available for
sport fisheries. 

Mark-selective ocean troll fisheries were removed from the sampling
data, because troll fisheries are only sampled for landed catch,
resulting in non-informative mark-rates that were always at or near 100% adipose marked.

Processing Steps:

* Read in data

* Eliminate records that can't be assigned to a FRAM fishery

* Combine Treaty/Non-treaty fishing pairs

* Group and summarize data by run year, fishery ID, and time step

* Calculate mark rates by year, fishery, and time step

  + Calculate encounter mark rates for mark-selective fisheries   

  + Calculate landed mark-rates for non-selective fisheries

* Exclude

  + Records with less than 20 sampled per year, fishery, and time step

  + Records for fisheries that did not have a mark selective or non-selective fishery flag (8, 2) in FRAM

* Summarize data by run year and fishery ID by grouping over time steps


### Mark Rates from RMIS

On May 17, 2022 RMIS "CatchSample" data was queried for Coho data
between 2010 and 2020.

These data were mapped to FRAM fisheries based on information in the
"catch_location_code", "fishery", and "gear" fields. See [fishery mapping description](#fishmap).

RMIS fields "period_type" and "period" were utilized to map data to FRAM
time steps (see Appendix x).

During quality control procedures records where "number_caught" or
"number_sampled" was either "na" or zero were removed. Additionally,
records with missing "mark_rates" were eliminated. Designated "M" mixed
mark-selective/non-selective fisheries also resulted in discarding the
record. Records were also removed if the fishery was listed as non-selective, but the time step mark rate was greater 98%. 

For each record the number marked were calculated as "number_caught"
times "mark_rate".

For each fishery the number caught and the number marked were first
summed over months within a time step and then over time steps within a
year.

Time step mark rates were computed after summing the number caught and the number marked over time steps. Likewise, annual mark rates were computed after summing the number caught and the number marked over years.

The mark rate was calculated as: Equation 3: $$
MarkRate_{Landed} = \frac{Marked_{Landed}}{Marked_{Landed}+Unmarked_{Landed}}
$$



### Mark Rates from FRAM

The Coho Technical Committee annually produces post-season Coho model
runs. These runs start with the final pre-season model runs and are
subsequently updated with best estimates of stock-specific escapements
and post-season assessments of landed and non-landed fisheries
mortalities. The database is housed on the Pacific Salmon
Commission's (PSC) [Extranet
website](https://extranet.psc.org/SitePages/Home.aspx). Model runs are
updated through 2020 and contained in an Access database called
"PSC_CoTC_PostSeason_CohoFRAMDB_thru2020_021622.mdb".

2010 to 2018 data was extracted from the "Mortality" table using
"framr", an r package that processes FRAM output data.

"LandedCatch", "MSFLandedCatch", "MSFNonRetention" data was summarized
by year, fishery, time step, and mark status. In FRAM, the "LandedCatch"
column contains the landed catch in a non-selective fishery, the
"MSFLandedCatch" column contains the landed catch in a mark-selective
fishery, and the "MSFNonRetention" column contains the mortality of Coho
released due to mark-selective fishing regulations. "MSFNonRetention"
mortalities were divided by the release mortality rate to convert
mortalities into released encounters.

Equation 4: $$
Encounters_{MSFNonRetention} = \frac{Mortality_{MSFNonRetention}}{ReleaseMortalityRate}
$$

Mixed mark-selective/non-selective fisheries were excluded from the
data.

For all fisheries, regardless of whether they were non-selective or
mark-selective, the "MSFLandedCatch" in combination with MSFNonRetention
were used to compute encounter mark rates. In Coho FRAM the landed catch
mark rate is identical to the encounter mark rate.

Equation 5: $$
Encounters_{MSF.Fishery} = MSFLandedCatch + Encounters_{MSF.NonRetention}
$$

Mark rates of encounters were computed as in equation 2.

### Combining FRAM mark rates with sampling mark rates

Mark rates directly provided by Washington sampling programs were filtered to mark selective sport fisheries and then combined in a ["full join"](#fulljoin) to FRAM mark selective fisheries and time steps.

Combining FRAM mark rates with those provided by RMIS took additional steps for annual comparisons. As RMIS only reports landed catch information only non-selective fisheries were compared using a "full join" of both data sources. In FRAM terminal fisheries are often modeled in the final time step (step 5) even if they occur in time 4. Additionally, RMIS fisheries are often reported by management instead of calendar months. This can result in the first or last few days of a month being reported in a different management month. The designation of a fishery as mark-selective or non-selective came from FRAM, because this field is frequently incorrect in RMIS. If a fishery is only modeled in time 5 then FRAM will not report the status (MSF or non-selective) of a fishery in non-modeled time steps. Therefore, when conducting a "full join" of RMIS and FRAM data based on FRAM fisheries designations, significant amounts of valuable RMIS data may be excluded. To prevent this, RMIS fisheries in time steps meeting the following conditions were included in the annual mark rate estimates:
* Mark rate < 0.96% &
* Missing FRAM fishery designation (FisheryFlag = "NA") &
* Adjoining time step (time step +/- 1) is non-selective (FisheryFlag = 2).


## Results

### Compare Sampling to FRAM

For the first comparison, annual mark rates from sampling or RMIS
depending on whether the fishery was mark selective sport or
non-selective, respectively were compared to FRAM mark rates. Mark rates
from RMIS or sampling programs will be henceforth referred to as either sampled
or observed mark rates. Incorporating salmon encounter information from
mark-selective sampling programs added valuable information about mark-selective sport fisheries to the analysis.

Tabular results of mark rates for all available fisheries and time steps
can be found in Appendix table [9.11](#markrates).

Initial adipose mark rate comparisons were grouped into 7 geographical
regions. Additionally, Puget Sound marine was separated into commercial
and sport fisheries.

Figures 6.1 and 6.2 were created by summing total landed catch or
encounters as well as total marked catch or encounters over all time
steps withing a year and fishery before computing mark rates. Box plot
6.1 displays the difference between the sampling mark rate and the FRAM
mark rate. The vertical line in the box represents the median
difference, the boundaries of the box represent the first quartile
(0.25) and the "whiskers" (outer lines) the third quartile (0.75).
Outliers are plotted as individual points beyond the whiskers.

The Wilcoxon test was used to compare mark rates from FRAM and sampling (RMIS, sampling programs). P-values smaller than 0.05 were selected to be statistically significant; i.e., FRAM mark rates are significantly different from sampling mark rates. The test was applied to annual mark rates. 
Of the 51 fisheries evaluated for mark rates differences between FRAM and sampling, 29 fisheries had a p-value of less than 0.05. Figures 6.3 and Table 6.2 display results from the Wilcoxon test. 

<br> **Alaska** <br> Sampling and RMIS mark rates are low and within a
few percentage points of each other. FRAM mark rate are higher than
sampling mark rates for all fisheries in this region. Differences are
statistically significant.

**Canada** <br> Mark rates in Canadian fisheries can vary widely with
very low mark rates in Northern and Central British Columbia and mark
rates around 50% for the West Coast of Vancouver Island. FRAM mark rates
can be higher as well as lower for individual fisheries within this
area. FRAM and sampling mark rates are within a similar order of
magnitude, except for Johnstone Strait net. Mark rate differences for
this fishery are large between FRAM (32.6%) and sampling (6.8%), but due
to low sample size statistical significance cannot be evaluated. An
evaluation of significance is also confounded by small sample sizes for
four other British Columbia fisheries. Only North British Columbia
troll and net, and North-Central troll had enough data points
to evaluate significance. Differences for these fisheries were
significant for North British Columbia net.

**Washington Coastal** <br> FRAM mark rates can be higher as well as
lower for individual fisheries within this area, although six of the eight fisheries had higher FRAM mark rates. 
Four of the Washington Coast fisheries had
enough data points to test statistical significance. Of these,
Quillayute and Grays Harbor net exhibited significant mark rate
differences.

**Washington Ocean** <br> For all six ocean fisheries FRAM mark rates were
higher than observed mark rates, with five of these fisheries evaluating as
significantly different, and 1 fishery being excluded from the analysis
of significance. 
Mark rate differences are larger in northern areas (ocean areas 3 and 4)
than in southern areas (ocean areas 1 and 2). Four of the fisheries with
significant mark-rate differences were well-sampled mark-selective sport
fisheries. These findings confirm earlier analysis by Robert Cope (Cope
2011) and warrant further evaluations. See the [case study](#casestudy) in this document for possible causes of the mark rate discrepancies for the Area 4/4B Treaty troll fishery.

**Puget Sound Commercial** <br> Puget Sound fisheries generally have
high mark rates, because many Puget Sound stocks are dominated by
mass-marked hatchery fish. Notable exceptions are Stillaguamish, Skagit,
and Snohomish Coho. FRAM mark rates can be higher as well as lower for
individual fisheries within this area. Of the 20 fisheries in this
aggregate, 16 contained a sufficient number of data points to be
evaluated using the Wilcoxon test. Of these, six fisheries had mark rates
that differed significantly between FRAM and sampling. Differences were
particularly pronounced for Areas 12/12B net, 10E net, and 6/7/7A net.

**Puget Sound Freshwater** <br> FRAM mark rates can be higher as well as
lower for individual fisheries within this area. Of the 13 fisheries in
this aggregate, only five contained a sufficient number of data points to
be evaluated using the Wilcoxon test. Of these, two fisheries, Skokomish
River net and Nisqually River net had mark rates that differed
significantly between FRAM and sampling. Differences were particularly
pronounced for Skokomish River net. This fishery also had a large
variance of the mark rate estimates.

**Puget Sound Sport** <br> FRAM mark rates can be higher as well as
lower for individual fisheries within this area. All ten fisheries in
this aggregate had sufficient number of data points to be evaluated
using the Wilcoxon test. Of these, seven fisheries had mark rates that
differed significantly between FRAM and sampling.

**South of Falcon (SoF)** <br> South of Falcon encompasses ocean areas
between Cape Falcon (Oregon) and the California/Mexico border. All five SoF
fisheries had higher FRAM mark rates. Three fisheries in this aggregate had
sufficient number of data points to be evaluated using the Wilcoxon
test. Of these, Newport sport had a mark rate that differed
significantly between FRAM and sampling.
<br>

```{r}


# mr_rmis_samp_long$type[mr_rmis_samp_long$type!="MR_sampl"]<-"MR_samp"


# gg_mr_bar_ts <- function(ts) {
#   filter(mr_fram_samp_long, TimeStep == ts) |> 
#     ggplot(aes(RunYear, val, color = type, fill = type)) +
#     geom_col(position = position_dodge()) +
#     scale_x_continuous("") +
#     scale_y_continuous("Mark rate", labels = scales::percent) +
#     scale_color_manual(values = pal, aesthetics = c("color", "fill")) +
#     facet_wrap(~TimeStep+FisheryID+FisheryName, labeller = label_wrap_gen(multi_line = F), ncol = 3) +
#     theme(legend.position = "top")
# }
# 
# gg_mr_bar_ts(2) + gg_mr_bar_ts(3)
# 
# wrap_plots(map(2:5, gg_mr_bar_ts), ncol = 2)




#produce box plots of absolute % differences

#find duplicates
# dplyr::group_by(RunYear, FisheryID, FisheryName, TimeStep, type) %>%
# dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
# dplyr::filter(n > 1L) 
  
box1<-mr_yr_fram_samp_rmis|> 
 left_join(d_uniquefishery2 %>% select(FisheryID,FisheryArea), by = c("FisheryID"))

 ggplot(box1 |> mutate(Label = paste(FisheryArea, "-", FisheryName)),aes(x = FisheryName, y = AbsPctDiff)) +
    coord_flip() +
    geom_boxplot(color = "orange", fill = "orange", alpha = 0.5, outlier.shape = NA) +
    geom_hline(yintercept = 0) +
    scale_x_discrete("") +
    scale_y_continuous("Sampling mark rate - FRAM mark rate") +
    labs(title ="Figure 6.1. Differences between Post-season Coho FRAM Modeled Mark Rates and Sampling Observations, 2010-18") +
   theme(axis.text=element_text(size=8), 
         axis.title= element_text(size=10)) +
   facet_wrap(~FisheryArea, scales = "free_y", nrow = 2)
   #plotly::ggplotly(a)
   # ggsave("box1.png", plot=box1, height=7, width=10)
 

```
*Differences were calculated as RMIS minus FRAM mark rates. Boxes to the left of the black/zero line result when FRAM mark rates are greater than RMIS mark rates.*

Figure 6.2 displays absolute mark rates from FRAM (blue bars) and sampling (yellow bars) by fishery with a separate panel for each region. 

```{r}
  #Bar plots of average annual catch by Fishery and Ocean Area
 bar1<-mr_yr_fram_samp_rmis|>
   select(RunYear,FisheryID,FisheryName,FRAM_MrkRate = MR,Samp_MrkRate = MR_sampl)|>
   left_join(d_uniquefishery2 %>% select(FisheryID,FisheryArea), by = c("FisheryID"))|>
   pivot_longer(names_to = "type", values_to = "val", cols =  c("FRAM_MrkRate","Samp_MrkRate"))|>
  group_by(FisheryID,FisheryName,FisheryArea,type)|>
  summarise(across(val, mean),.groups="drop")
 
 ggplot(bar1, aes(FisheryName, val, color = type, fill = type)) +
    coord_flip() +
    geom_col(position = position_dodge(), show.legend = T) +
    scale_color_manual(values = pal, aesthetics = c("color", "fill")) +
    facet_wrap(~FisheryArea, labeller = label_wrap_gen(multi_line = F), scales = "free_y", nrow = 2) +
    #labs(subtitle = d$FisheryName[1]) +
    theme(legend.position = "top",
          legend.text = element_text(size=8),
          legend.key.size = unit(0.4, 'cm'),
          legend.title=element_blank(),
          axis.text=element_text(size=6),
          axis.text.x = element_text(angle = 75),
          strip.text.x = element_text(size = 10))+
    ggtitle("Figure 6.2. 2010-18 Average Fishery Mark Rates from FRAM and Sampling Observations")+
    xlab("Fishery")+
    ylab("Mark Rate")
 
```

<br>

```{r results='asis'}
# test whether mark rate differences are statistically significant for each fishery; use annual mark rates for comparisons
FisheryWilcoxTest<-mr_yr_fram_samp_rmis|>
  select(RunYear, FisheryID, FisheryName, FRAM_MrkRate =MR ,Samp_MrkRate = MR_sampl) |>
  # pivot_longer(names_to = "type", values_to = "val", cols =  c("FRAM_MrkRate","Samp_MrkRate"))|>
  group_by(FisheryID)|>
  filter(FisheryID %in% (mr_yr_fram_samp_rmis|>
  select(RunYear, FisheryID) |> group_by(FisheryID) %>% summarize(n = n()) |> filter(n >= 5))$FisheryID) %>%
  # do(tidy(t.test(.$FRAM_MrkRate, 
  #                .$Samp_MrkRate, 
  #                mu=0,alt = "two.sided",
  #                paired = True)))
 do(tidy(wilcox.test(.$FRAM_MrkRate, 
                 .$Samp_MrkRate)))
  x<-nrow(FisheryWilcoxTest)
  
               
# graph fishery in order of wilcox significance
WilcoxGraph<-FisheryWilcoxTest |> 
  left_join(mr_yr_fram_samp_rmis |> select(FisheryID, FisheryName), "FisheryID") |>
  mutate(Significant = if_else(p.value > 0.05, "Non-significant", "Significant")) |>
  distinct()
  
 ggplot(WilcoxGraph, aes(x = reorder(FisheryName, -p.value), y = p.value, fill = Significant, color = Significant)) +
  geom_col() +
  geom_hline(yintercept = 0.05, linetype = "dotted") +
  theme_bw() +
  labs(title ="Figure 6.3. Wilcoxon p-values by Fishery", subtitle= "Fisheries with significant mark rate differences (p<0.05) in turquoise") +
   xlab("Fisheries")+
   ylab("p-value")+
  coord_flip() 
# summarize Wilcox significance by region
WilcoxTable1<-left_join(WilcoxGraph,
                         d_uniquefishery2 %>% select(FisheryID,FisheryArea), by = c("FisheryID"))|>
    select(FisheryID,FisheryArea,Significant)|>
    group_by(FisheryArea)|>
    summarise(n=n(),.groups= "drop")
  
WilcoxTable2<-left_join(WilcoxGraph,
                         d_uniquefishery2 %>% select(FisheryID,FisheryArea), by = c("FisheryID"))|>
    select(FisheryID,FisheryArea,Significant)|>
    group_by(FisheryArea,Significant)|>
    summarise(n=n(),.groups= "drop")|>
    group_by(FisheryArea)|>
    mutate(Fisheries = sum(n))|>
    mutate(`#Significant`=n)|>
    ungroup()|>
    filter(Significant =="Significant")|>
    dplyr::rename(`#Fisheries` = Fisheries)

    WilcoxTable2<-WilcoxTable2[,c(1,4,5)] |>
     
  # Format as a table
  gt::gt() |> 
  # Add title text
  gt::tab_header(title = "Table 6.2. Number of Fisheries Evaluated with Wilcoxon and Number of Fisheries with Siginificant Mark Rate Differences in Each Area")
  
    WilcoxTable2

    
    
```


<br>
Figure 6.3 displays annual mark rates for fisheries that had at least 3 annual values. Generally, the variability is higher for observed mark rates from sampling than modeled mark rate from FRAM.

```{r annualMR}
 
 # Bar plots of annual mark rates by fishery FRAM/Sampling
 
 #exclude_fish=c(18,20,21,44,54,63,74,77,84,98,108,113,117,128,131,138,162,166,172,174,179,181,182,187,194,195,196,197)
# eliminate fisheries with less than 3 years of data
x<-mr_yr_fram_samp_rmis|>
  count(FisheryName)|>
  filter(n>2)
mr_yr_fram_samp_rmis1<-mr_yr_fram_samp_rmis|>
  filter(FisheryName %in% x$FisheryName)|>
  dplyr::rename(FRAM_MrkRate = MR, Samp_MrkRate = MR_sampl)


bar2<-mr_yr_fram_samp_rmis1|> 
 left_join(d_uniquefishery2 %>% select(FisheryID,FisheryArea), by = c("FisheryID"))|>
  pivot_longer(names_to = "type", values_to = "val", cols =  c("FRAM_MrkRate","Samp_MrkRate"))

 # filter(!FisheryID %in% exclude_fish)
# gg_mr_bar_fishery <- function(fid) {
#   d <- filter(mr_fram_samp_meants, FisheryID == fid)

write.csv(bar2,"bar2.csv")
  
    ggplot(bar2, aes(RunYear, val, color = type, fill = type)) +
    geom_col(position = position_dodge(), show.legend = T) +
   #scale_x_continuous("") +
    #scale_y_continuous("Mark rate", labels = scales::percent) +
    scale_color_manual(values = pal, aesthetics = c("color", "fill")) +
    facet_wrap(~FisheryID+FisheryName, labeller = label_wrap_gen(multi_line = F), nrow = 7) +
    #labs(subtitle = d$FisheryName[1]) +
    theme(legend.position = "top",
          legend.text = element_text(size=8),
          legend.key.size = unit(0.4, 'cm'),
          legend.title=element_blank(),
          axis.text=element_text(size=7),
          axis.text.x = element_text(angle = 90),
          strip.text.x = element_text(size = 7))+
    ggtitle("Figure 6.3. 2010-18 Fishery Mark Rates from FRAM and Sampling by Year")+
    xlab("Year")+
    ylab("Mark Rate")

    
# }
#Overview side-by-side bars
#sum over time steps and years. Group into fishery aggregates from same #region with similar FRAM/Sampling relationships

selectfish = c(17,33,37,40,41,39,43,44,47,50,71,81,83,88,91,92,93,97,118,120,122,129,136,138,142,152,154,171,172,174,178,179,181,194,195,196,197,198)    

mr_fram_samp_aggs<-mr_fram_samp_long|>
  group_by(FisheryID,FisheryName,type)|>
    summarize(val=mean(val))|>
  filter(FisheryID %in% selectfish)|>
  mutate(
     Area = case_when(FisheryID==17~ "SoF",
                      FisheryID==33|FisheryID==37 ~ "A1,2Spt",
                      FisheryID==40|FisheryID==41 ~ "A3,4Spt",
                      FisheryID==39|FisheryID==43|FisheryID==44 ~ "T_OcnTrl",
                      FisheryID==47|FisheryID==50|FisheryID==71 ~ "CoastNet",
                      FisheryID==81 ~ "JDF_Net",
                      FisheryID==88 ~ "7,7A_Net",
                      FisheryID==91|FisheryID==92|FisheryID==93 ~ "JDF&SJI_Spt",
                      FisheryID==97 ~ "B_ham_Net",
                      FisheryID==118|FisheryID==120|FisheryID==122|FisheryID==129 ~ "CntrPS_Net",
                      FisheryID==136|FisheryID==138|FisheryID==142 ~ "SPS_Net",
                      FisheryID==152 ~ "HC_Spt",
                      FisheryID==154 ~ "12,12B_Net",
                      FisheryID==171|FisheryID==172|FisheryID==178|FisheryID==179 ~ "NCBC_Net",
                      FisheryID==174|FisheryID==181 ~ "WCVI_Net",
                      FisheryID==194|FisheryID==195|FisheryID==196|FisheryID==197|FisheryID==198 ~ "Alaska"
                      )
     )
  mr_fram_samp_aggs<-mr_fram_samp_aggs|>
  group_by(Area,type)|>
    summarize(val=mean(val)) |>
    filter(!is.na(Area))
  
  # Create vector of ordered fisheries by FRAM value
  FRAMorder <- mr_fram_samp_aggs |> 
    ungroup() |>
    filter(type == "MR_fram") |>
    arrange(val) |>
    mutate(Area = factor(Area))
  
  # ggplot(mr_fram_samp_aggs |> ungroup() |> mutate(Area = factor(Area, levels = FRAMorder$Area)), aes(val,Area, color = type, fill = type)) +
  #   geom_col(position = position_dodge(), show.legend = T) +
  #   scale_color_manual(values = pal, aesthetics = c("color", "fill")) +
  #   theme(legend.position = "top",legend.text = element_text(size=8),
  #         legend.key.size = unit(0.4, 'cm'),legend.title=element_blank())+
  #   ggtitle("Figure 6.4. 2010-18 Aggregate Fishery Mark Rates from FRAM and Sampling")+
  #   xlab("Mark Rate")+
  #   ylab("Fishery")
  
```

Table 6.3 places fisheries in three categories. Agreement is listed as 'good' when mark rates have an absolute difference of less than 10%, 'moderate' below 30%, and poor above 30%.

```{r results='asis'}
# Calculates the relative difference by fishery and ranks fisheries

Rank_RelDiff_Fish <-bar1|>
pivot_wider(names_from = type, values_from = val)|>
mutate(MR_Diff = FRAM_MrkRate-Samp_MrkRate)|>
filter(FRAM_MrkRate>0.1)|>
mutate(AbsRelDiff = abs((FRAM_MrkRate-Samp_MrkRate)/FRAM_MrkRate) )|>
mutate(Agreement = if_else(AbsRelDiff<0.10,"good",if_else(AbsRelDiff<0.30,"moderate","poor")))
  Rank_RelDiff_Fish<-Rank_RelDiff_Fish[order(Rank_RelDiff_Fish$AbsRelDiff),]
  #ggplot(Rank_RelDiff_Fish,aes(x=RelDiff))+geom_histogram(binwidth=0.1) #+
   # scale_x_continuous(limits = c(0, 1))
  # Format as a table
 Rank_RelDiff_Fish$FRAM_MrkRate<-round(Rank_RelDiff_Fish$FRAM_MrkRate,3)
 Rank_RelDiff_Fish$Samp_MrkRate<-round(Rank_RelDiff_Fish$Samp_MrkRate,3)
 Rank_RelDiff_Fish$AbsRelDiff<-round(Rank_RelDiff_Fish$AbsRelDiff,3)
 Rank_RelDiff_Fish<- Rank_RelDiff_Fish[,-6]|>
  gt::gt() |>
  # Add title text
  gt::tab_header(title = "'Good', 'Moderate', 'Poor' Agreement between FRAM and Sampling Mark Rates")

     Rank_RelDiff_Fish

  
```
<br>
Table 6.4 displays the mean mark rate difference(FRAM - Sampling) by fishery area. 
Mark rates were first calculated for each fishery and year, then averaged over years, and finally averaged over fishing areas. When averaging mark rates over broad geographic areas such as Southeast Alaska, Canada, or Puget Sound mark rate differences are quite small (<5%) with the exception of Washington Coastal and Ocean fisheries (11.7% and 14.8% respectively).

```{r results='asis'}
# Calculates the mean mark rate difference by fishery aggregate

MR_RMSE<-bar1|>
pivot_wider(names_from = type, values_from = val)|>
mutate(MR_Diff = FRAM_MrkRate-Samp_MrkRate)

#mutate(Abs_Diff = abs(MR_Diff))
#write.csv(MR_RMSE,"MR_RMSE.csv")
MR_RMSE<-MR_RMSE|>
group_by(FisheryArea)|>
summarise(across(MR_Diff,mean),.groups="drop")
#mutate(Root_SQ_Diff = sqrt(SQ_Diff))
#rounds to 2 decimals
#numeric_columns<-sapply(MR_RMSE,mode) =='numeric'
MR_RMSE$MR_Diff<-round(MR_RMSE$MR_Diff,3)

MR_RMSE<-MR_RMSE|>
gt::gt() |>
# Make column headers bold
#gt::cols_label(.list = list(FisheryArea = gt::md("**Area**"),
#Abs_Diff = gt::md("**Mean_Abs_Diff**"),
#)) |>
# Add title text
gt::tab_header(title = "Table 6.4. Mean Mark Rate Difference by Fishery Area")

MR_RMSE

```

### Compare Sampling to RMIS

Adipose mark rates from sampling programs along the West Coast are
reported to RMIS. Mark rates in RMIS are stratified into several time
intervals, with weekly and monthly strata being the most common,
depending on the sample size and the sample design. RMIS mark rates are
computed by dividing the number of adipose marked Coho by the number of
total Coho sampled for a given fishery and time stratum. For the mark
rate analysis, we used RMIS and sampling data as the mark rate source.
As RMIS data is derived from sampling data, verification that these data
match became part of the data validation of this project.

Figure 6.4 displays 2010-2018 adipose mark rates by fishery in
side-by-side bar graphs.

```{r}
#compare sampling to RMIS

# create annual sums of landed and marked and then calculate mark rate
# eliminate fishery 33 (Area 1 sport) because Oregon data is not included in ocean sampling report
  mr_rmis_samp<-filter(mr_rmis_samp, FisheryID !=33)
mr_rmis_samp_annual<-mr_rmis_samp|>
  group_by(RunYear,FisheryID,FisheryName)|>
    summarize_at(c("Total_rmis","Marked_rmis","Total_samp","Marked_samp"), sum)|>
  mutate(MR_RMIS = Marked_rmis/Total_rmis, MR_samp = Marked_samp/Total_samp)|>
select(RunYear, FisheryID, FisheryName, MR_samp ,MR_RMIS) |>
  pivot_longer(names_to = "Source", values_to = "Mark_Rate", cols =  c("MR_samp","MR_RMIS"))
 
ggplot(mr_rmis_samp_annual, aes(RunYear, Mark_Rate, color = Source, fill = Source)) +
    geom_col(position = position_dodge(), show.legend = T) +
    scale_x_continuous(breaks = seq(2010, 2018, by = 1)) +
    scale_y_continuous("Mark Rate", labels = scales::percent) +
    scale_color_manual(values = pal, aesthetics = c("color", "fill")) +
    facet_wrap(~FisheryID+FisheryName, labeller = label_wrap_gen(multi_line = F), nrow = 5) +
    #labs(subtitle = d$FisheryName[1]) +
    theme(legend.position = "top",legend.text = element_text(size=8),
          legend.key.size = unit(0.4, 'cm'),
          legend.title=element_blank(),axis.text=element_text(size=8),
          strip.text.x = element_text(size = 10))+
    ggtitle("Figure 6.4. 2010-18 Fishery Mark Rates from RMIS and Sampling")+
    xlab("Year")



# gg_mr_bar_fishery(33) + gg_mr_bar_fishery(37)+ 
#   plot_layout(guides='collect') &
#   theme(legend.position='bottom')
```

As expected, RMIS and sampling mark rates closely match. Upon
examination, the small differences in mark rates were found to be caused
by slight differences in time step definitions; i.e., sampling data was
summarized on a calendar month basis and RMIS data on a statistical
month basis. Since time steps with small sample sizes were excluded from
the analysis, this resulted in some time steps exceeding the sample size
threshold for one data source and being retained while falling short in
the other data source and being eliminated.

## Conclusions

For many fisheries, agreement between FRAM mark rates and sampling mark rates is moderate or poor. Although when aggregating over fisheries and years within large geographic areas, mark rate differences can be quite small (see table 6.4).

For some fisheries FRAM mark rates are consistently higher than sampling mark rates. This is especially apparent for Washington coastal and ocean fisheries and warrants [further investigation](#casestudy).

In non-selective fisheries, FRAM mark rates are largely a function of modeled marked and unmarked stock abundances and base period exploitation rates. Since base period exploitation rates are static, FRAM mark rates are generally less variable across years than sampling mark rates. 

Surprisingly, some of the greatest mark rate differences can be observed in freshwater fisheries; i.e., Skokomish net, Skagit sport. Due to the terminal nature of these fisheries, mark rates are usually well known and represented by the mark rate of the local stock. Therefore, differences may be due to sampling error or fishing in locations where the hatchery (predominantly adipose marked) and natural (predominantly unmarked) stock components segregate.    

Mark rate comparisons are just one parameter useful in assessing the accuracy of the FRAM model. As mentioned earlier, FRAM mark rates are a function of base period exploitation rates and stock specific abundances. It is often difficult to assess whether mark rate differences are caused by a change in stock distributions or erroneous data. Both data sources, FRAM and RMIS have many potential sources of error. We found mistakes in FRAM abundance data, an annual input, that resulted in significant mark rate errors for some stocks and years. Conversely, the sampling data had many instances of problematic sampling sizes or highly improbable mark rate observations. Well sampled fisheries are crucial to [additional more in-dept analyses](#casestudy).


# Exploitation Rate Analysis

Explain why marked only
## Introduction

## Trends in CWT Recoveries
insert graphs from ealier powerpoint

## Results

### Case Study: Area 4/4B Treaty Troll {#casestudy}
The Washington North Coast Treat troll fishery in ocean areas 4/4B is a well sampled, non-selective fishery. Average Coho catch exceeds 20,000 (excluding 2015, 2016) in the past decade. 
Due to these characteristics, the fishery was chosen as a test case to investigate mark rate differences between FRAM and RMIS. 

From 2010 to 2020 the FRAM mark rate averages 49% and RMIS mark rate 33%. This study examines whether the lower observed mark rates are likely due to missing unmarked wild fish or substantial differences in the stock composition of marked hatchery Coho.

For the purpose of computing pseudo-exploitation rates the same subset of fisheries was utilized in the denominator as for the exploitation rate comparison to FRAM (see paragraph x).

#### Steps for conducting the analysis:
<br>
1. Summarize the marked FRAM abundances by stock and year used to calculate FRAM and RMIS exploitation rates. For a calculation of marked abundances see section x.

$$MarkedAbundance_{Stk,Yr} = {\sum_{fish \in Study}Mortalities_{Stk,Yr} + Escapement_{Stk,Yr}}$$
2. Calculate the associated unmarked abundance. 
Unmarked abundances could not be calculated as mortalities plus catch, because of the bias introduced by releasing unmarked Coho in mark-selective fisheries. 
The stock- and year-specific mark rate was summarized from post-season FRAM validation runs using the time 4 'working cohort' from FRAM's "Cohort" table. This mark rate was then applied to the marked abundance from step 1 to calculate the associated unmarked abundance.
$$UnmarkedAbundance_{Stk,Yr} = \frac{MarkedAbundance_{Stk,Yr}}{MarkRate_{Stk,Yr}}-MarkedAbundance_{Stk,Yr}$$
3. Compute FRAM and RMIS catches as abundance times pseudo-exploitation rate. For a calculation of pseudo [exploitation rates]{} see x.

$$MarkedFRAMCatch_{Stk,Yr}=MarkedAbundance_{Stk,Yr} * ER.FRAM_{Stk,Yr}$$
$$UnMarkedFRAMCatch_{Stk,Yr}=UnMarkedAbundance_{Stk,Yr} * ER.FRAM_{Stk,Yr}$$
$$MarkedRMISCatch_{Stk,Yr}=MarkedAbundance_{Stk,Yr} * ER.RMIS_{Stk,Yr}$$
$$UnMarkedRMISCatch_{Stk,Yr}=UnMarkedAbundance_{Stk,Yr} * ER.RMIS_{Stk,Yr}$$
4. Sum catches over stocks by year for Area 4/4B treaty troll for marked and unmarked FRAM and RMIS catches.

$$Catch_{Yr}= {\sum_{Stk}Catch_{Stk,Yr} }$$
5. Summarize FRAM catches of marked and unmarked hatchery fish and marked and unmarked wild fish in the treaty troll fishery. The catches can be retrieved from standard FRAM output and were summarized by year.
The total annual FRAM catch was summed over hatchery as well as wild stocks landed in the fishery. Values summarized from post-season FRAM runs matched the values calculated in step 4 above. This provides a validation of the methods uses to calculate FRAM pseudo-exploitation rates. Furthermore, the FRAM database also provided the wild catch and total catch of the fishery.

$$FRAMTotCatch_{Yr}=\sum{(AllStockCatch_{HatMrkd}+AllStockCatch_{HatUM}+AllStockCatch_{WildMrkd}+AllStockCatch_{WildUM})}$$
<br>
6. Calculate FRAM and RMIS mark rates by dividing the marked catch by the total FRAM catch.
$$MR_{FRAM}=\frac{FRAMMrkdCatch_{Yr}}{FRAMTotCatch_{Yr}}$$
$$MR_{RMIS}=\frac{RMISMrkdCatch_{Yr}}{FRAMTotCatch_{Yr}}$$
Where, <br>
  Stk       = Stock<br>
  Yr        = Year<br>
  Mrkd      = Marked<br>
  UM        = Unmarked

#### Results

Table 7.1 displays FRAM and RMIS landed catches by mark status, observed mark rates from sampling programs, and FRAM and RMIS mark rates as calculated in steps 1-6 above. 
```{r results ='asis'}
CaseStudyTable<-d_ERtrollsum|>
   # DT::datatable(filter = 'top', 
   #                   extensions = 'Buttons', 
   #                   options = list(
   #                     dom = 'Bfrtip',
   #                buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
  
  #DA help. Can't get table to render
  
  gt::gt() |> 
  # Make column headers bold
  gt::cols_label(.list = list(`Year` = gt::md("**Year**"),
                              `FRAM.Mrkd.Hatchery.Catch` = gt::md("**FRAM Markd Hatchery Catch**"), 
                              `FRAM..UM.Hatchery.Catch` = gt::md("**FRAM UM Hatchery Catch**"),
                              `FRAM.Hatchery.Mark.Rate`=gt::md("**FRAM Hatchery Mark Rate**"),
                              `RMIS.Mrkd.Hatchery.Catch` = gt::md("**RMIS Markd Hatchery Catch**"), 
                              `RMIS.UM.Hatchery.Catch` = gt::md("**RMIS UM Hatchery Catch**"),
                              `RMIS.Hatchery.Mark.Rate`=gt::md("**RMIS Hatchery Mark Rate**"),
                              `All.Stocks.FRAM.Catch` = gt::md("**All Stocks FRAM Catch**"), 
                              `Observed.Mark.Rate` = gt::md("**Observed Mark Rate**"),
                              `FRAM.Mark.Rate`=gt::md("**FRAM Mark Rate**"),
                              `RMIS.Reconstructed.Mark.Rate` = gt::md("**RMIS Reconstructed Mark Rate**")                  
                              )) |> 
  # Add title text
  gt::tab_header(title = "Table 7.1 ") 
```

Although the hatchery stock composition displayed some differences between FRAM and RMIS (see table x), the mark rate of the hatchery stocks was very similar and averaged 89% for both data sources. 

```{r results ='asis'}

#DA help. can't get table to render
tbltop10<-d_top10|>
  gt::gt()
```

The mean percent error between observed marked catches and FRAM marked catches is 55% and between observed marked catches and RMIS is -2%. The average RMIS marked catch deviates only 100 Coho from the observed catch of 6700. There is also good agreement in observed marked and RMIS catches on an annual basis (R Square=0.89). 
Given that there is good agreement between RMIS and FRAM hatchery mark rates and RMIS and observed marked catches, will leave only unmarked wild Coho unaccounted for. This points towards missing/underestimated wild abundance as the source of the discrepancy. The average composition of the catch based on sampling and hatchery mark rates is approximately 32% hatchery marked, 2% hatchery unmarked, and 64% wild unmarked. Given these proportions and assumptions, FRAM misses approximately 30% of the wild abundance. Since the mark rate discrepancies diminish for fisheries further South, Washington South Coast and Columbia River stocks are less likely to be the cause of the mark rate differences.  
We recommend additional evaluations and if possible Genetic Stock Identification (GSI) studies to investigate further.

# Improve Mixed Stock Model (MSM)

## Introduction

## Mixed Stock Model Program Documentation {#MSMGuide}

## Combining Contemporary CWTS with Existing Base Period

WDFW investigated steps associated with combining contemporary coded wire tags with old base period coded wire tags to update base period exploitation rates. For Chinook, the FRAM calibration procedure utilizes CWTs outside of the base period years for the White River fingerling and yearling Chinook stocks (1991 to 1996 fishing years for White River; 2007 to 2013 fishing years for the Chinook base period).  However, the Chinook out-of-base procedure does not combine tags from outside of the base period years with tags from within the base period years.  To adapt the Chinook out-of-base procedure to several stocks at once for coho and potentially combining data with current base period data, we identified several potential challenges and considerations detailed below.  
Note: where potential solutions are described, additional investigation is required.<br>
1.)	Issue: Poor/No CWT sampling in some contemporary fisheries<br>
Description: <br>
To calculate base period exploitation rates for contemporary tags, modelers must develop estimates of cohort size (denominator in the base period exploitation rate calculation).  Because cohort size is a combination of escapement and mortality (both fishing and natural mortality from later time steps), it is not possible to exclude fisheries from out-of-base development that are poorly sampled and achieve correct cohort sizes.  Incorrect cohort sizes influence base period exploitation rate calculations for all fishery-time steps in the model, and therefore, even fisheries that are sampled well will require correct cohort sizes to estimate base exploitation rates.
There are several potential causes of poor sampling:<br>
a.) Sampling did not occur and no CWTs were recovered despite fishing. 
<br>
b.) Sampling did occur but there were sampling strata which included catch with 0 CWT recoveries.  These strata would not contribute to CWT expansions to represent the full catch of the fishery. 
<br>
c.) Only a small portion of the fishery catch was sampled, resulting in a small number of CWTs returned which increases uncertainty in stock compositions. 
<br>
d.) The total catch of a fishery is unknown.  Catch did occur and CWTs were recovered, but were expanded to represent a CWT estimated number by using a surrogate area or time period. 
<br>
Potential Solutions: The Chinook Technical Committee (CTC) creates coded wire tags (referred to as auxiliary tags) when developing their annual exploitation rate analysis.  These tags are developed by regional CTC leads and represent impacts in fisheries where poor or no sampling occurred.  It may be possible to develop similar auxiliary tags for coho to address this issue.
<br>
For freshwater areas it may be possible to develop auxiliary tags by assuming 100% of the catch comes from the local stock.  However, this assumption becomes problematic in freshwater areas that contain multiple stocks.   It would also be problematic if attempting to create auxiliaries for a marine area due to the mixed-stock nature of catch.  It is possible in mixed-stock fisheries to use base period CWT catches to develop contemporary auxiliaries, assuming that the base period CWTs are representative of contemporary CWTs. However, at least two adjustments would be required.  

* An adjustment must be made to base period CWT estimates to account for differences in fishery magnitude (base period vs. contemporary).  This adjustment may be achieved via post-season fishery scalers, which represent the magnitude of the contemporary fishery relative to the base period.

* An adjustment must be made to base period CWT estimates to account for differences in abundance (base period vs. contemporary).  It would be most appropriate to compare base period cohort size to contemporary cohort size, but the contemporary cohort size would be dependent upon the auxiliaries imputed. Therefore, this step represents a mathematical challenge as the cohort size is necessary to develop auxiliary CWTs, which are necessary to develop cohort size.  WDFW considered using a different abundance metric (e.g., escapement) to expand auxiliary CWTs. However, given changes to fishing regimes since the base period, a contemporary year could theoretically have an equivalent escapement to a base period year, but have a very different total number of fishing mortalities, and therefore a very different cohort.
<br>

2.)	Consideration: When to aggregate annual data to produce base exploitation rate estimates
<br>
Description: There are two potential approaches to producing base period exploitation rates.  One approach could be to calculate exploitation rates for each stock-age-fishery-time step annually, subsequently averaging annual rates across years to produce a base period exploitation rate.  An alternative approach could be to aggregate CWT catch and cohort sizes across years to produce a base period exploitation rate.  See an example of each approach below:

```{r results ='asis'}
dplyr::tibble(`Year` = c(2017, 2018, 2019),
  `Cohort Size` =c(500, 1000, 750),
     `CWT Catch`=c(50, 70, 150)  ) |> 
  
  # Format as a table
  gt::gt() |> 
  # Make column headers bold
  gt::cols_label(.list = list(`Year` = gt::md("**Year**"), 
                              `Cohort Size` = gt::md("**Cohort Size**"),
                              `CWT Catch`=gt::md("**CWT Catch**")
                              )) |> 
  # Add title text
  gt::tab_header(title = "Example")



```
$$Approach 1 BPER = \frac{\frac{50}{500}+\frac{70}{1000}+\frac{150}{750}}{3}$$

$$Approach 2 BPER = \frac{50+70+150}{500+1000+750} $$

In approach 1, the BPER is calculated as 12.3%.  In approach 2, the BPER is calculated as 12%.

The advantage to approach 1 is that each year receives an equal weight in determining the exploitation rate, irrespective of fishery catch or abundance. In approach 2, there is a greater weighting for years with a higher abundances.

The advantage to approach 2 is that many fisheries have a small number of CWTs recovered.  If we use approach 1, it is possible that many zeroes will be averaged along with years with recoveries and an aggregate may better capture small sample size scenarios.
<br>
3.)	Consideration: Need for additional QAQC following out-of-base procedures<br>
Description: There were a number of anomalous results produced for out-of-base stocks relative to in-base stocks during the development of the Chinook base period that warranted additional investigation and QAQC (see [FRAM
documentation](https://framverse.github.io/fram_doc/)). As out-of-base expansions are applied to fisheries recoveries during the out-of-base years, additional expansions to the estimated CWTs should be examined.
<br>
4.)	Issue: In the contemporary period, when fishing has not occurred in a particular area-time period, how can we develop base period exploitation rates in case that fishery does occur in the future?
Description: Contemporary fisheries are generally of a smaller magnitude than during the coho base period years, with increasing spatio-temporal restrictions.  In some cases, fishery-time step combinations that previously had catch no longer have catches in the contemporary period.  This is problematic if there were a need to model the fishery in the future but solely use contemporary coded wire tags.
<br>
Potential Solutions: Develop methods to use current base period coded wire tags to represent the contemporary period.  If solely using contemporary tags (e.g., not combining with current base period tags), it may be possible to use the current base period information as a surrogate for these fishery-time periods.  To do so, it may be necessary to divide both fishery catch and CWT recoveries from the current base period by a large number (e.g., 10000) prior to combining with contemporary tags.  Doing so would have minimal effect on the contemporary cohort size because added impacts would be minimal.  However, through the use of a fishery scaler, it would be possible in any future runs that did include the surrogate fishery-time step to model catches.  If using this strategy, in the contemporary tag set, calculated base period exploitation rates and base period catches would be low, but could be increased via the fishery scaler to produce desired catches.
<br>
5.)	Issue: How to model stock-specific non-retention impacts during the out-of-base procedure
Description: Expanded CWT recoveries only include landed catch, as CWTs are not recovered from released fish.  Non-retention fisheries do occur for coho coastwide, and impacts from these fisheries should be accounted for during the cohort reconstruction process.  The stock composition for non-retention impacts would typically be determined during the “all stocks” run, which is not performed during an out-of-base procedure. 
<br>
Potential Solutions: It may be possible to determine the percentage contribution of the stock-age to the marked retained catch in a fishery-time step and use that percentage to estimate the number of encounters for the stock given an estimate of marked released encounters in the fishery.  To examine this metric, biologists would need coast-wide estimates of marked released and marked retained fish by fishery-time step.  It may be possible to alternatively calculate an average non-retention impacts per marked fish and apply this across fisheries to produce estimates more quickly at the cost of fine-scale fishery accuracy.
<br>
6.)	Issue: During processing, it is possible for exploitation rates to exceed 100%
Description: During the out-of-base process, a number of expansions are occurring on CWTs and it is mathematically possible to produce exploitation rates that exceed 100% for a stock-age.  In reality, it is not possible for a stock to experience exploitation rates greater than 100%.
<br>
Potential Solutions: If a stock-age exceeds a 100% exploitation rate, it may be valuable to build and error check in the code that alerts the modeler when this occurs.  If QAQC does not find any errors in the code or input information, it may be possible to reset any exploitation rates over 100% to a maximum value (e.g., 95%).
<br>
7.)	Issue: If a fishery occurred in the contemporary period, but not the base period, how can we integrate it into the current base period?
Description: If there is a contemporary fishery that was not fished during the base period years, no tag recoveries will exist for the fishery.  We cannot directly add the contemporary CWTs from the fishery to the base years if it did not occur because doing so will affect the cohort size and all of the other fishery base period exploitation rates. 
<br>
Potential Solutions: It may be possible to add the contemporary impacts to the old base period via CWTs that have been scaled by dividing by a large number (e.g., 10,000).  The resulting impacts to the cohort size would be negligible and it would be possible to scale the fishery in subsequent years using a fishery scaler.  

# Appendix

## List of Coho FRAM Fisheries

```{r echo = FALSE}
readRDS(paste0(table_dir,"framvs_doc_lu_fishery_coho.rds"))
```

## List of Coho FRAM Stocks

```{r echo = FALSE}
readRDS(paste0(table_dir,"framvs_doc_lu_stock_coho.rds"))
```

## Table of CWT Adjustments (Expansions), FRAM Catches, RMIS Catches, and Sampled Catches by Fishery and Year

```{r}
# see fram_samp_filla.xlsx 

#compare FRAM annual landed to RMIS
rmis_landed<-rmis_landed|>
  filter(!is.na(Total_rmis))
fram_samp_full<-rmis_landed[,c(1:2,4:5)]|>
  full_join(fram_landed,
            by=c("RunYear","FisheryID"))|>
  left_join(d_uniquefishery,
            by = c("FisheryID"))|>
  filter(FisheryID!=0)|>
  filter(FisheryID!=300)|>
  filter(RunYear!=2020)|>
  left_join(d_rmis_no_samp|>
              select(-number_sampled),
            by=c("RunYear","FisheryID","FisheryName"))
 

action <- na.omit(read.csv(paste0(table_dir,"/MR_Action.csv")))

fram_samp_fulla <- fram_samp_full |>
  select(-c(Kept_M_fram, Sampled_rmis)) |>
  ungroup() |>
  #mutate(Xpansion = NA) |> 
  pivot_longer(-c(FisheryID, FisheryName, RunYear), names_to = "Source", values_to = "Landed") |>
  group_by(FisheryID, FisheryName, Source) |>
  pivot_wider(names_from = RunYear, values_from = Landed) |>
  mutate(Source = if_else(Source == "Total_fram", "FRAM",
                          if_else(Source == "Total_rmis", "RMIS",
                                  if_else(Source == "number_caught", "Sampled", Source)))) |>
  arrange(FisheryID, Source) |>
  ungroup() |>
  rowwise(FisheryID, FisheryName, Source) |>
  mutate(Total = sum(c_across(`2010`:`2019`),
                     na.rm = TRUE)) |>
  ungroup() |>
  left_join(action, 
            select(FisheryID,Action),
            by = c("FisheryID", "FisheryName")) |> 
  bind_rows(fram_samp_full |>
              select(-c(Kept_M_fram, Sampled_rmis)) |>
              ungroup() |>
              #mutate(Xpansion = NA) |> 
              pivot_longer(-c(FisheryID, FisheryName, RunYear), names_to = "Source", values_to = "Landed") |>
              group_by(FisheryID, FisheryName, Source) |>
              pivot_wider(names_from = RunYear, values_from = Landed) |>
              mutate(Source = if_else(Source == "Total_fram", "FRAM",
                                      if_else(Source == "Total_rmis", "RMIS",
                                              if_else(Source == "number_caught", "Sampled", Source)))) |>
              arrange(FisheryID, Source) |>
              ungroup() |>
              left_join(action, 
                        select(FisheryID,Action),
                        by = c("FisheryID", "FisheryName")) |> 
              pivot_longer(`2010`:`2019`, names_to = "Year", values_to = "Value") |> 
              pivot_wider(names_from = "Source", values_from = "Value") |> 
              mutate(Expansion = case_when(
                        Action == "Remove  fishery" ~ 0,
                        FisheryID == 198 ~ 1,
                        FisheryID == 98 ~ 0,
                        FisheryID == 91 ~ FRAM / RMIS,
                        (abs(FRAM - RMIS) > 400 & abs(FRAM - RMIS) / RMIS > 0.095)|FRAM<=10|is.na(FRAM)|RMIS<=10|is.na(RMIS)|is.na(Sampled)|Sampled<=10|RMIS/Sampled>8 ~ 0,
                        is.na(RMIS) ~ 0,
                        is.na(Sampled) ~ 0,
                        TRUE ~ RMIS / Sampled
                    )
              ) |> 
              group_by(Year) |> 
              mutate(Expansion = if_else(FisheryID == 97, 
                                         (RMIS[FisheryID == 98] + RMIS) / (Sampled[FisheryID == 98] + Sampled),
                                         Expansion),
                     Expansion = if_else(is.na(Expansion), 
                                         RMIS / Sampled,
                                         Expansion)) |> #filter(FisheryID %in% 97:98) |> 
              ungroup() |> 
              select(-c(FRAM, RMIS, Sampled)) |> 
              pivot_wider(names_from = Year, values_from = Expansion) |> 
              mutate(Source = "Xpansion")
  ) |> 
  arrange(FisheryID, Source)
write.csv(fram_samp_fulla, "fram_samp_fulla.csv", na = "")
```


```{r tab_foo,   results='asis' } 
table <- fram_samp_fulla
table$Total<-round(table$Total,0)

reactable(table |> mutate(Source = if_else(Source == "Xpansion", "Expansion", Source)),
          defaultColDef = colDef(align = "center",
                                 headerStyle = list(background = "#f7f7f8")),
          rowStyle = function(index){
            if(index %% 4 == 0){
              list(`border-bottom` = "solid")
            } else{
              FALSE
            }
          },
          columns = list(FisheryID = colDef(name = "Fishery ID",
                                            filterable = TRUE,
                                            style = function(value, index){
                                               if(index %% 4 == 0){
                                                 list(background = "#ff8c00", fontWeight = "normal")
                                               }
                                              }),
                         FisheryName = colDef(name = "Fishery Name",
                                              minWidth = 140,
                                              filterable = TRUE,
                                              style = function(value, index){
                                                 if(index %% 4 == 0){
                                                   list(background = "#ff8c00", fontWeight = "normal")
                                                 }
                                                }),
                         Source = colDef(filterable = TRUE,
                                            style = function(value, index){
                                               if(index %% 4 == 0){
                                                 list(background = "#ff8c00", fontWeight = "normal")
                                               }
                                              }),
                         `2010` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if(is.na(value) | table$`2010`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2011` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if(is.na(value) | table$`2011`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2012` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2012`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2013` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2013`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2014` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2014`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2015` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2015`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2016` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2016`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2017` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2017`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2018` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2018`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         `2019` = colDef(na = "-",
                                         cell = function(value, index){
                                             if(is.na(value)){
                                               value <- "-"
                                             } else if(value == 0){
                                               value
                                             } else if(index %% 4 == 0) {
                                               value <- format(round(value, 2), nsmall = 2)
                                             } else {
                                               value
                                             }
                                         },
                                         style = function(value, index){
                                           if(index %% 4 == 1){
                                             fram <- index
                                             rmis <- index + 1
                                             sampled <- index + 2
                                             xpansion <- index + 3
                                           } else if(index %% 4 == 2){
                                             fram <- index - 1
                                             rmis <- index
                                             sampled <- index + 1
                                             xpansion <- index + 2
                                           } else if(index %% 4 == 3){
                                             fram <- index - 2
                                             rmis <- index - 1
                                             sampled <- index
                                             xpansion <- index + 1
                                           } else{
                                             fram <- index - 3
                                             rmis <- index - 2
                                             sampled <- index  - 1
                                             xpansion <- index
                                           }
                                           if(index %% 4 == 0){
                                             list(background = "#ff8c00", fontWeight = "bold")
                                           } else if (is.na(value) | table$`2019`[xpansion] == 0){
                                             list(background = "#a9a9a9")
                                           } else{
                                             FALSE
                                           }
                                         }),
                         Total = colDef(na = "-",
                                        style = function(value, index){
                                               if(index %% 4 == 0){
                                                 list(background = "#ff8c00", fontWeight = "normal")
                                               }
                                              }),
                         Action = colDef(filterable = TRUE,
                                         align = "left",
                                         minWidth = 270,
                                         style = function(value, index){
                                               if(index %% 4 == 0){
                                                 list(background = "#ff8c00", fontWeight = "normal")
                                               }
                                              })
                     ),
          bordered = FALSE,
          outlined = TRUE,
          highlight = TRUE,
          showPageSizeOptions = TRUE,
          pageSizeOptions = c(4, 12, 24, 58),
          defaultPageSize = 12) %>%
          reactablefmtr::add_title("Table 4.4. FRAM Catches, RMIS Catches, Catch Associated with Sampling and Expansions by Fishery and Year", font_size=16)


# write.csv(fram_samp_full,"fram_samp_full.csv")
```


## Coded-wire-tag groups which were listed as clipped under “cwt_1st_mark”, but were released as an unclipped group.

```{r results='asis' }
t_unclipped<-t_unclipped|>
  gt::gt()
t_unclipped
```
## Coho Salmon Production Regions and Management Units.

```{r results='asis'}
t_prmu<-t_prmu|>
  gt::gt()
t_prmu
```
## Coho Stock Mapping by Tag Code

```{r results='asis'}

# stockmaptable<-as.data.frame(d_stockmap)
#      filter(brood_year>2009)|> 
#  DT::datatable(filter = 'top', 
#                     extensions = 'Buttons', 
#                     options = list(
#                       dom = 'Bfrtip',
#                       buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
```

## Run Information 

FRAM Access Database Name: 'FramVS2-PSC-Coho-Backwards-86 to 2016 BEST.mdb'

FRAM Version: 2.20March25

Base Period ID: 27

Table X. Description of model runs used for the sensitivity analysis

```{r echo = FALSE, results='asis'}
tablex_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_x_section1c.xlsx"))

reactable::reactable(tablex_1c |> 
                     dplyr::rename(`Run Name` = RunName),
                     defaultColDef = reactable::colDef(vAlign = "center", 
                                                       headerVAlign = "bottom", 
                                                       align = "center",
                                                       headerStyle = list(background = "#f7f7f8")),
                     highlight = TRUE,
                     outlined = TRUE,
                     height = 500,
                     showPageSizeOptions = TRUE,
                     defaultPageSize = 20,
                     pageSizeOptions = c(10, 20, 50, 100),
                     columns = list(
                      `Run ID` = reactable::colDef(minWidth = 80),
                      `Run Name` = reactable::colDef(minWidth = 225),
                      Description = reactable::colDef(minWidth = 200),
                      `Run Year` = reactable::colDef(minWidth = 90)
                     ),
                     rowStyle = function(index){
                       if(tablex_1c$`Run Year`[index] == 2013){
                         list(background = "#ADD8E680")
                       } else if(tablex_1c$`Run Year`[index] == 2015){
                         list(background = "#90ee9080")
                       }
                     }
                )
```

## List of Fisheries Set to Zero

```{r echo = FALSE, results = 'asis'}
# **ID**|**Fishery Title**|**ID**|**Fishery Title**|**ID**|**Fishery Title**
# :---:|:---|:---:|:---|:---:|:---
# 48|Grays Harbor Sport (2.2)|75|Hoh R C&S|126|Green/Duwamish R Net
# 49|South Grays Harbor Spt|82|6D NT Net (Dungeness Bay & R)|127|Green/Duwamish R Sport
# 50|Grays Harbor Est. Net|83|6D T Net (Dungeness Bay & R)|128|Lk Wash/Samm./Tribs Spt
# 51|Humptulips R Sport|84|Elwha R Net|134|Puyallup R Net
# 52|Lower Chehalis R Net|85|West JDF Straits Trib Net|135|Puyallup R Sport
# 53|Humptulips R C&S|86|East JDF Straits Trib Net|139|A 13C NT Net (Chambers)
# 54|Chehalis R Sport|89|East JDF Straits Trib Sport|140|A 13C TNet (Chambers)
# 55|Humptulips R Net|90|West JDF Straits Trib Sport|141|A 13A NT Net (Carr Inlet)
# 56|Upper Chehalis R Net|94|Dungeness R Sport|142|A 13A T Net (Carr Inlet)
# 57|Chehalis R C&S|95|Elwha R Sport|147|Nisqually R Net
# 58|Wynochee R Sport|98|Nooksack R Net|148|McAllister Creek Net
# 59|Hoquiam R Sport|99|Nooksack R Sport|150|Nisqually R Sport
# 60|Wishkah R Sport|100|Samish R Sport|151|Deschutes R Sport
# 61|Satsop R Sport|103|Skagit R Net|155|A 9/9A NT Net
# 62|Quinault R Sport|104|Skagit River Test Net|156|A 9/9A T Net (On Res)
# 63|Quinault R Net|105|Swinomish Channel Net|157|A 12A NT Net (Quilcene Bay)
# 64|Quinault R C&S|108|Skagit R Sport|158|A 12A T Net (Quilcene Bay)
# 65|Queets R Sport|111|WA A 8D NT Net (Tulalip Bay)|161|Skokomish R Net
# 66|Clearwater R Sport|112|WA A 8D T Net (Tulalip Bay)|162|Quilcene R Net
# 67|Salmon R Sport (Queets)|113|Stillaguamish R Net|163|12, 12B Trib FW Sport
# 68|Queets R Net|114|Snohomish R Net|164|12A Trib FW Sport
# 69|Queets R C&S|116|Stillaguamish R Sport|165|12C, 12D Trib FW Sport
# 70|Quillayute R Sport|117|Snohomish R Sport|166|Skokomish R Sport
# 71|Quillayute R Net|121|WA A 10A NT Net (Elliott Bay)|167|Lower Fraser R Term Catch
# 72|Quillayute R C&S|122|WA A 10A T Net (Elliott Bay)|168|Upper Fraser R Term Catch
# 73|Hoh R Sport|123|WA A 10E NT Net (East Kitsap)|169|Lower Fraser River Sport
# 74|Hoh R Net|124|WA A 10E T Net (East Kitsap)|184|Fraser R Gill Net
# ---|---|125|WA A 10F-G T Net (Lake Union)|193|Alberni Canal Sport

table4_1c <- readxl::read_excel(paste0(table_dir, "SA_Table_4_section1c.xlsx"))

reactable::reactable(table4_1c,
                     outlined = TRUE,
                     striped = TRUE,
                     height = 500,
                     showPageSizeOptions = TRUE,
                     defaultPageSize = 20,
                     pageSizeOptions = c(10, 20, 50, 100),
                     highlight = TRUE,
                     defaultColDef = reactable::colDef(vAlign = "center", 
                                                       headerVAlign = "bottom", 
                                                       #align = "center", 
                                                       headerStyle = list(background = "#f7f7f8")),
                     columns = list(
                       ID = reactable::colDef(minWidth = 20, align = "center")
                     )
                    )
```

## Treaty/Non-treaty Net Fishery Pairs

```{r table, echo= FALSE, results='asis'}
dplyr::tibble(`NT FishID` = c(80,82,87,96,101,109,111,119,121,123,130,132,137,139,141,143,145,153,155,157,159),
  `T FishID` =c(81,83,88,97,102,110,112,120,122,124,131,133,138,140,142,144,146,154,156,158,160),
  `Fishery Name` = c("A4B6CNet","Ar6D Net","A6-7ANet","A7BCDNet","Ar 8 Net","Ar8A Net","Ar8D Net","Ar10 Net","Ar10ANet","Ar10ENet","Ar11 Net","Ar11ANet","Ar13 Net","Ar13CNet","Ar13ANet","Ar13DNet","A13FKNet","1212BNet","A9-9ANet","Ar12ANet","A12CDNet")
       ) |> 
 knitr::kable(caption = "Treaty/non-treaty net fishery pairs") |>
  kableExtra::kable_styling() |>
  kableExtra::scroll_box( width="100%",height = "250px")

```

## FRAM Time Steps

```{r appendi2, echo= FALSE, results='asis'}
dplyr::tibble(`Time Step` = c(1,2,3,4,5),
  Duration =c("Jan-June","July","August","September","Oct-Dec"),
       ) |> 
  # Format as a table
  gt::gt() |> 
  # Make column headers bold
  gt::cols_label(.list = list(`Time Step` = gt::md("**Time Step**"), 
                              Duration = gt::md("**Duration**"))) |> 
  # Add title text
  gt::tab_header(title = "Coho FRAM time steps")
```

## Mark Rates from FRAM and Sampling by Fishery and Time Step {#markrates}

```{r tableMR, echo= FALSE, results='asis'}

  MR_Table<-mr_fram_samp_rmis[,c(1,2,3:7, 9:12, 14)]|>
  left_join(d_uniquefishery %>% select(FisheryID,FisheryName), by = c("FisheryID"))
  
    MR_Table |> 
      mutate(TimeStep = factor(TimeStep),
             RunYear = factor(RunYear),
             FisheryID = factor(FisheryID),
             FisheryFlag = factor(FisheryFlag),
             across(c(5:6, 9:10), ~round(.x)),
             across(c(7, 11), ~round(.x, 2))) |>
      dplyr::rename(`Run Year` = RunYear,
             `Fish ID` = FisheryID, 
             `Fish Name` = FisheryName,
             `Time Step` = TimeStep,
             `Flag` = FisheryFlag,
             `FRAM Total` = Total,
             `FRAM Marked` = Marked,
             `FRAM Mark Rate` = MR,
             `FRAM Type` = Type.x,
             `Sampl total` = Tot_samp,
             `Sampl Marked` = Marked_samp,
             `Sampl Mark Rate` = MR_samp,
             `Sampl Type` = Type.y)|>
      DT::datatable(filter = 'top', 
                    extensions = 'Buttons', 
                    options = list(
                      dom = 'Bfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print')))
    
```

# Bibliography

Cope, R. (2011). Causes and Effects of Bias in Anticipated Mark Rates in
Mark-Selective Fisheries for Coho Salmon. Portland: PFMC.

FRAM Overview citation needed

Selective Fishery Evaluation Technical Committee (2021). ANALYSIS OF COHO SALMON DOUBLE INDEX TAG (DIT) GROUPS 
FOR BROOD YEARS 1998–2011. Vancouver (BC): PSC

Auerbach, Dan, Hagen-Breaux A., Dapp D., Bellman M., Miler O.. 2020. FRAM_VS User Guide. 14. January. https://wdfw-fp.github.io/framvs_doc/.

Cope, Robert. 2011. Causes and Effects of Bias in Anticipated Mar Rates in Mark-Selective Fisheries for Coho Salmon. Salmon Methodology Review Report, Portland: Pacific Fishery Management Council.

Hagen-Breaux, Angelika. 2018. BkFRAM May 2 2018.docx. Olympia: WDFW.

Model Evaluation Workgroup. 2008. Fishery Regulation Assessment Model (FRAM) - An Overview for Coho and Chinook v 3.0. PFMC.

Pacific Salmon Commission. 2014. Pacific Salmon Treaty. Vancouver: Pacific Salmon Commission.

Pacific Salmon Commission. 2020. Pacific Salmon Treaty. Vancouver: Pacific Salmon Commission.

Packer, James and Cook-Tabor C. 2007. Coho FRAM Base Period Development. Vancouver: Pacific Salmon Commission. {"MSMDoc}

